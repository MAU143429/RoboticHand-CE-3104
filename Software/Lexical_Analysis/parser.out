Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    BREAK
    COMMA
    DELAY
    DIVIDE
    DOTDOT
    ELSE
    ELSEIF
    EQEQ
    FN
    FOR
    GT
    GTE
    IF
    INTEGER
    LCRLBRACKET
    LOOP
    LPAREN
    LSQRBRACKET
    LT
    LTE
    MAIN
    MINUS
    MOVE
    OPERA
    PLUS
    PRINT
    QUOT
    RANGE
    RCRLBRACKET
    RETURN
    RPAREN
    RSQRBRACKET
    TIMES
    WHILE
    WRONG_ID

Grammar

Rule 0     S' -> line
Rule 1     line -> variable
Rule 2     line -> empty
Rule 3     variable -> LET ID ASSIGN expression SEMICOLON line
Rule 4     expression -> INT
Rule 5     expression -> TRUE
Rule 6     expression -> FALSE
Rule 7     expression -> ID
Rule 8     empty -> <empty>

Terminals, with rules where they appear

ARROW                : 
ASSIGN               : 3
BREAK                : 
COMMA                : 
DELAY                : 
DIVIDE               : 
DOTDOT               : 
ELSE                 : 
ELSEIF               : 
EQEQ                 : 
FALSE                : 6
FN                   : 
FOR                  : 
GT                   : 
GTE                  : 
ID                   : 3 7
IF                   : 
INT                  : 4
INTEGER              : 
LCRLBRACKET          : 
LET                  : 3
LOOP                 : 
LPAREN               : 
LSQRBRACKET          : 
LT                   : 
LTE                  : 
MAIN                 : 
MINUS                : 
MOVE                 : 
OPERA                : 
PLUS                 : 
PRINT                : 
QUOT                 : 
RANGE                : 
RCRLBRACKET          : 
RETURN               : 
RPAREN               : 
RSQRBRACKET          : 
SEMICOLON            : 3
TIMES                : 
TRUE                 : 5
WHILE                : 
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

empty                : 2
expression           : 3
line                 : 3 0
variable             : 1

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . variable
    (2) line -> . empty
    (3) variable -> . LET ID ASSIGN expression SEMICOLON line
    (8) empty -> .

    LET             shift and go to state 4
    $end            reduce using rule 8 (empty -> .)

    line                           shift and go to state 1
    variable                       shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> line .



state 2

    (1) line -> variable .

    $end            reduce using rule 1 (line -> variable .)


state 3

    (2) line -> empty .

    $end            reduce using rule 2 (line -> empty .)


state 4

    (3) variable -> LET . ID ASSIGN expression SEMICOLON line

    ID              shift and go to state 5


state 5

    (3) variable -> LET ID . ASSIGN expression SEMICOLON line

    ASSIGN          shift and go to state 6


state 6

    (3) variable -> LET ID ASSIGN . expression SEMICOLON line
    (4) expression -> . INT
    (5) expression -> . TRUE
    (6) expression -> . FALSE
    (7) expression -> . ID

    INT             shift and go to state 9
    TRUE            shift and go to state 10
    FALSE           shift and go to state 11
    ID              shift and go to state 7

    expression                     shift and go to state 8

state 7

    (7) expression -> ID .

    SEMICOLON       reduce using rule 7 (expression -> ID .)


state 8

    (3) variable -> LET ID ASSIGN expression . SEMICOLON line

    SEMICOLON       shift and go to state 12


state 9

    (4) expression -> INT .

    SEMICOLON       reduce using rule 4 (expression -> INT .)


state 10

    (5) expression -> TRUE .

    SEMICOLON       reduce using rule 5 (expression -> TRUE .)


state 11

    (6) expression -> FALSE .

    SEMICOLON       reduce using rule 6 (expression -> FALSE .)


state 12

    (3) variable -> LET ID ASSIGN expression SEMICOLON . line
    (1) line -> . variable
    (2) line -> . empty
    (3) variable -> . LET ID ASSIGN expression SEMICOLON line
    (8) empty -> .

    LET             shift and go to state 4
    $end            reduce using rule 8 (empty -> .)

    line                           shift and go to state 13
    variable                       shift and go to state 2
    empty                          shift and go to state 3

state 13

    (3) variable -> LET ID ASSIGN expression SEMICOLON line .

    $end            reduce using rule 3 (variable -> LET ID ASSIGN expression SEMICOLON line .)

