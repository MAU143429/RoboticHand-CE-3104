Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    RANGE
    WRONG_ID

Grammar

Rule 0     S' -> root
Rule 1     root -> main root
Rule 2     root -> function root
Rule 3     root -> procedure root
Rule 4     root -> let root
Rule 5     root -> empty empty
Rule 6     main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
Rule 7     procedure -> FN ID LPAREN params RPAREN prodbody
Rule 8     prodbody -> LCRLBRACKET line RCRLBRACKET
Rule 9     function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
Rule 10    funbody -> ARROW output
Rule 11    output -> INTEGER
Rule 12    output -> BOOLEAN
Rule 13    end -> RETURN expression SEMICOLON
Rule 14    line -> loop line
Rule 15    line -> for line
Rule 16    line -> while line
Rule 17    line -> if line
Rule 18    line -> let line
Rule 19    line -> move line
Rule 20    line -> moveList line
Rule 21    line -> delay line
Rule 22    line -> println line
Rule 23    line -> break line
Rule 24    line -> declaration line
Rule 25    line -> empty empty
Rule 26    declaration -> ID LPAREN params RPAREN SEMICOLON
Rule 27    declaration2 -> ID LPAREN params RPAREN
Rule 28    params -> ID arg
Rule 29    params -> INT arg
Rule 30    params -> TRUE arg
Rule 31    params -> FALSE arg
Rule 32    params -> empty empty
Rule 33    arg -> COMMA params
Rule 34    arg -> empty empty
Rule 35    loop -> LOOP LCRLBRACKET line RCRLBRACKET
Rule 36    for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
Rule 37    for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
Rule 38    while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
Rule 39    while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET
Rule 40    move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
Rule 41    moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
Rule 42    fingerList -> STRING COMMA STRING
Rule 43    fingerList -> STRING COMMA fingerList
Rule 44    delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
Rule 45    unit -> QUOT MIN QUOT
Rule 46    unit -> QUOT MIL QUOT
Rule 47    unit -> QUOT SEG QUOT
Rule 48    println -> PRINT EXPR LPAREN args RPAREN SEMICOLON
Rule 49    args -> INT body
Rule 50    args -> ID body
Rule 51    args -> opera body
Rule 52    args -> TRUE body
Rule 53    args -> FALSE body
Rule 54    args -> STRING body
Rule 55    body -> COMMA args
Rule 56    body -> COMMA body
Rule 57    body -> empty empty
Rule 58    text -> QUOT ID QUOT
Rule 59    elseiforelse -> elseif
Rule 60    elseiforelse -> else
Rule 61    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 62    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 63    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 64    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 65    else -> ELSE LCRLBRACKET line RCRLBRACKET
Rule 66    compare -> EQEQ
Rule 67    compare -> LTE
Rule 68    compare -> GTE
Rule 69    compare -> LT
Rule 70    compare -> GT
Rule 71    compare -> DIF
Rule 72    expression -> INT
Rule 73    expression -> TRUE
Rule 74    expression -> FALSE
Rule 75    expression -> opera
Rule 76    expression -> ID
Rule 77    expression -> negative
Rule 78    let -> LET ID ASSIGN operand SEMICOLON
Rule 79    let -> LET ID ASSIGN bool SEMICOLON
Rule 80    let -> LET ID ASSIGN declaration2 SEMICOLON
Rule 81    opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN
Rule 82    operator -> PLUS
Rule 83    operator -> MINUS
Rule 84    operator -> DIVIDE
Rule 85    operator -> ASTR
Rule 86    operator -> TIMES
Rule 87    operand -> INT
Rule 88    operand -> opera
Rule 89    operand -> ID
Rule 90    operand -> negative
Rule 91    negative -> MINUS INT
Rule 92    bool -> TRUE
Rule 93    bool -> FALSE
Rule 94    bool -> ID
Rule 95    break -> BREAK
Rule 96    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 10
ASSIGN               : 78 79 80
ASTR                 : 85
BOOLEAN              : 12
BREAK                : 95
COMMA                : 33 40 41 42 43 44 55 56 81 81
DELAY                : 44
DIF                  : 71
DIVIDE               : 84
DOTDOT               : 37
DOTDOTEQ             : 36
ELSE                 : 65
ELSEIF               : 63 64
EQEQ                 : 66
EXPR                 : 48
FALSE                : 31 53 74 93
FN                   : 6 7 9
FOR                  : 36 37
GT                   : 70
GTE                  : 68
ID                   : 7 9 26 27 28 36 37 50 58 76 78 79 80 89 94
IF                   : 61 62
IN                   : 36 37
INT                  : 29 36 36 37 37 44 49 72 87 91
INTEGER              : 11
LCRLBRACKET          : 6 8 9 35 36 37 38 39 61 62 63 64 65
LET                  : 78 79 80
LOOP                 : 35
LPAREN               : 6 7 9 26 27 38 40 41 44 48 81
LSQRBRACKET          : 41
LT                   : 69
LTE                  : 67
MAIN                 : 6
MIL                  : 46
MIN                  : 45
MINUS                : 83 91
MOVE                 : 40 41
OPERA                : 81
PLUS                 : 82
PRINT                : 48
QUOT                 : 45 45 46 46 47 47 58 58
RANGE                : 
RCRLBRACKET          : 6 8 9 35 36 37 38 39 61 62 63 64 65
RETURN               : 13
RPAREN               : 6 7 9 26 27 38 40 41 44 48 81
RSQRBRACKET          : 41
SEG                  : 47
SEMICOLON            : 13 26 40 41 44 48 78 79 80
STRING               : 40 42 42 43 44 54
TIMES                : 86
TRUE                 : 30 39 52 73 92
WHILE                : 38 39
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

arg                  : 28 29 30 31
args                 : 48 55
body                 : 49 50 51 52 53 54 56
bool                 : 40 41 79
break                : 23
compare              : 38 61 62 63 64
declaration          : 24
declaration2         : 80
delay                : 21
else                 : 60
elseif               : 59
elseiforelse         : 62 64
empty                : 5 5 25 25 32 32 34 34 57 57 61 63
end                  : 9
expression           : 13 38 38 61 61 62 62 63 63 64 64
fingerList           : 41 43
for                  : 15
funbody              : 9
function             : 2
if                   : 17
let                  : 4 18
line                 : 6 8 9 14 15 16 17 18 19 20 21 22 23 24 35 36 37 38 39 61 62 63 64 65
loop                 : 14
main                 : 1
move                 : 19
moveList             : 20
negative             : 77 90
opera                : 51 75 88
operand              : 78 81 81
operator             : 81
output               : 10
params               : 7 9 26 27 33
println              : 22
procedure            : 3
prodbody             : 7
root                 : 1 2 3 4 0
text                 : 
unit                 : 
while                : 16

Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    root                           shift and go to state 1
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 1

    (0) S' -> root .



state 2

    (1) root -> main . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    main                           shift and go to state 2
    root                           shift and go to state 9
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) root -> function . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    function                       shift and go to state 3
    root                           shift and go to state 10
    main                           shift and go to state 2
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 4

    (3) root -> procedure . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    procedure                      shift and go to state 4
    root                           shift and go to state 11
    main                           shift and go to state 2
    function                       shift and go to state 3
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 5

    (4) root -> let . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    let                            shift and go to state 5
    root                           shift and go to state 12
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    empty                          shift and go to state 6

state 6

    (5) root -> empty . empty
    (96) empty -> .

    $end            reduce using rule 96 (empty -> .)

    empty                          shift and go to state 13

state 7

    (6) main -> FN . MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> FN . ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> FN . ID LPAREN params RPAREN prodbody

    MAIN            shift and go to state 14
    ID              shift and go to state 15


state 8

    (78) let -> LET . ID ASSIGN operand SEMICOLON
    (79) let -> LET . ID ASSIGN bool SEMICOLON
    (80) let -> LET . ID ASSIGN declaration2 SEMICOLON

    ID              shift and go to state 16


state 9

    (1) root -> main root .

    $end            reduce using rule 1 (root -> main root .)


state 10

    (2) root -> function root .

    $end            reduce using rule 2 (root -> function root .)


state 11

    (3) root -> procedure root .

    $end            reduce using rule 3 (root -> procedure root .)


state 12

    (4) root -> let root .

    $end            reduce using rule 4 (root -> let root .)


state 13

    (5) root -> empty empty .

    $end            reduce using rule 5 (root -> empty empty .)


state 14

    (6) main -> FN MAIN . LPAREN RPAREN LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 17


state 15

    (9) function -> FN ID . LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> FN ID . LPAREN params RPAREN prodbody

    LPAREN          shift and go to state 18


state 16

    (78) let -> LET ID . ASSIGN operand SEMICOLON
    (79) let -> LET ID . ASSIGN bool SEMICOLON
    (80) let -> LET ID . ASSIGN declaration2 SEMICOLON

    ASSIGN          shift and go to state 19


state 17

    (6) main -> FN MAIN LPAREN . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 20


state 18

    (9) function -> FN ID LPAREN . params RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> FN ID LPAREN . params RPAREN prodbody
    (28) params -> . ID arg
    (29) params -> . INT arg
    (30) params -> . TRUE arg
    (31) params -> . FALSE arg
    (32) params -> . empty empty
    (96) empty -> .

    ID              shift and go to state 21
    INT             shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    RPAREN          reduce using rule 96 (empty -> .)

    params                         shift and go to state 22
    empty                          shift and go to state 26

state 19

    (78) let -> LET ID ASSIGN . operand SEMICOLON
    (79) let -> LET ID ASSIGN . bool SEMICOLON
    (80) let -> LET ID ASSIGN . declaration2 SEMICOLON
    (87) operand -> . INT
    (88) operand -> . opera
    (89) operand -> . ID
    (90) operand -> . negative
    (92) bool -> . TRUE
    (93) bool -> . FALSE
    (94) bool -> . ID
    (27) declaration2 -> . ID LPAREN params RPAREN
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 31
    ID              shift and go to state 27
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    operand                        shift and go to state 28
    bool                           shift and go to state 29
    declaration2                   shift and go to state 30
    opera                          shift and go to state 32
    negative                       shift and go to state 33

state 20

    (6) main -> FN MAIN LPAREN RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 38


state 21

    (28) params -> ID . arg
    (33) arg -> . COMMA params
    (34) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 40
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 39
    empty                          shift and go to state 41

state 22

    (9) function -> FN ID LPAREN params . RPAREN funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> FN ID LPAREN params . RPAREN prodbody

    RPAREN          shift and go to state 42


state 23

    (29) params -> INT . arg
    (33) arg -> . COMMA params
    (34) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 40
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 43
    empty                          shift and go to state 41

state 24

    (30) params -> TRUE . arg
    (33) arg -> . COMMA params
    (34) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 40
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 44
    empty                          shift and go to state 41

state 25

    (31) params -> FALSE . arg
    (33) arg -> . COMMA params
    (34) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 40
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 45
    empty                          shift and go to state 41

state 26

    (32) params -> empty . empty
    (96) empty -> .

    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 46

state 27

    (89) operand -> ID .
    (94) bool -> ID .
    (27) declaration2 -> ID . LPAREN params RPAREN

  ! reduce/reduce conflict for SEMICOLON resolved using rule 89 (operand -> ID .)
    SEMICOLON       reduce using rule 89 (operand -> ID .)
    LPAREN          shift and go to state 47

  ! SEMICOLON       [ reduce using rule 94 (bool -> ID .) ]


state 28

    (78) let -> LET ID ASSIGN operand . SEMICOLON

    SEMICOLON       shift and go to state 48


state 29

    (79) let -> LET ID ASSIGN bool . SEMICOLON

    SEMICOLON       shift and go to state 49


state 30

    (80) let -> LET ID ASSIGN declaration2 . SEMICOLON

    SEMICOLON       shift and go to state 50


state 31

    (87) operand -> INT .

    SEMICOLON       reduce using rule 87 (operand -> INT .)
    COMMA           reduce using rule 87 (operand -> INT .)
    RPAREN          reduce using rule 87 (operand -> INT .)


state 32

    (88) operand -> opera .

    SEMICOLON       reduce using rule 88 (operand -> opera .)
    COMMA           reduce using rule 88 (operand -> opera .)
    RPAREN          reduce using rule 88 (operand -> opera .)


state 33

    (90) operand -> negative .

    SEMICOLON       reduce using rule 90 (operand -> negative .)
    COMMA           reduce using rule 90 (operand -> negative .)
    RPAREN          reduce using rule 90 (operand -> negative .)


state 34

    (92) bool -> TRUE .

    SEMICOLON       reduce using rule 92 (bool -> TRUE .)
    RPAREN          reduce using rule 92 (bool -> TRUE .)


state 35

    (93) bool -> FALSE .

    SEMICOLON       reduce using rule 93 (bool -> FALSE .)
    RPAREN          reduce using rule 93 (bool -> FALSE .)


state 36

    (81) opera -> OPERA . LPAREN operator COMMA operand COMMA operand RPAREN

    LPAREN          shift and go to state 51


state 37

    (91) negative -> MINUS . INT

    INT             shift and go to state 52


state 38

    (6) main -> FN MAIN LPAREN RPAREN LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 53
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 39

    (28) params -> ID arg .

    RPAREN          reduce using rule 28 (params -> ID arg .)


state 40

    (33) arg -> COMMA . params
    (28) params -> . ID arg
    (29) params -> . INT arg
    (30) params -> . TRUE arg
    (31) params -> . FALSE arg
    (32) params -> . empty empty
    (96) empty -> .

    ID              shift and go to state 21
    INT             shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    RPAREN          reduce using rule 96 (empty -> .)

    params                         shift and go to state 75
    empty                          shift and go to state 26

state 41

    (34) arg -> empty . empty
    (96) empty -> .

    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 76

state 42

    (9) function -> FN ID LPAREN params RPAREN . funbody LCRLBRACKET line end RCRLBRACKET
    (7) procedure -> FN ID LPAREN params RPAREN . prodbody
    (10) funbody -> . ARROW output
    (8) prodbody -> . LCRLBRACKET line RCRLBRACKET

    ARROW           shift and go to state 80
    LCRLBRACKET     shift and go to state 78

    funbody                        shift and go to state 77
    prodbody                       shift and go to state 79

state 43

    (29) params -> INT arg .

    RPAREN          reduce using rule 29 (params -> INT arg .)


state 44

    (30) params -> TRUE arg .

    RPAREN          reduce using rule 30 (params -> TRUE arg .)


state 45

    (31) params -> FALSE arg .

    RPAREN          reduce using rule 31 (params -> FALSE arg .)


state 46

    (32) params -> empty empty .

    RPAREN          reduce using rule 32 (params -> empty empty .)


state 47

    (27) declaration2 -> ID LPAREN . params RPAREN
    (28) params -> . ID arg
    (29) params -> . INT arg
    (30) params -> . TRUE arg
    (31) params -> . FALSE arg
    (32) params -> . empty empty
    (96) empty -> .

    ID              shift and go to state 21
    INT             shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    RPAREN          reduce using rule 96 (empty -> .)

    params                         shift and go to state 81
    empty                          shift and go to state 26

state 48

    (78) let -> LET ID ASSIGN operand SEMICOLON .

    FN              reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    LET             reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    $end            reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    LOOP            reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    FOR             reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    WHILE           reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    IF              reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    MOVE            reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    DELAY           reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    PRINT           reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    BREAK           reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    ID              reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    RCRLBRACKET     reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)
    RETURN          reduce using rule 78 (let -> LET ID ASSIGN operand SEMICOLON .)


state 49

    (79) let -> LET ID ASSIGN bool SEMICOLON .

    FN              reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    LET             reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    $end            reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    LOOP            reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    FOR             reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    WHILE           reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    IF              reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    MOVE            reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    DELAY           reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    PRINT           reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    BREAK           reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    ID              reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    RCRLBRACKET     reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)
    RETURN          reduce using rule 79 (let -> LET ID ASSIGN bool SEMICOLON .)


state 50

    (80) let -> LET ID ASSIGN declaration2 SEMICOLON .

    FN              reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    LET             reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    $end            reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    LOOP            reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    FOR             reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    WHILE           reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    IF              reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    MOVE            reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    DELAY           reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    PRINT           reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    BREAK           reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    ID              reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    RCRLBRACKET     reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)
    RETURN          reduce using rule 80 (let -> LET ID ASSIGN declaration2 SEMICOLON .)


state 51

    (81) opera -> OPERA LPAREN . operator COMMA operand COMMA operand RPAREN
    (82) operator -> . PLUS
    (83) operator -> . MINUS
    (84) operator -> . DIVIDE
    (85) operator -> . ASTR
    (86) operator -> . TIMES

    PLUS            shift and go to state 83
    MINUS           shift and go to state 84
    DIVIDE          shift and go to state 85
    ASTR            shift and go to state 86
    TIMES           shift and go to state 87

    operator                       shift and go to state 82

state 52

    (91) negative -> MINUS INT .

    SEMICOLON       reduce using rule 91 (negative -> MINUS INT .)
    EQEQ            reduce using rule 91 (negative -> MINUS INT .)
    LTE             reduce using rule 91 (negative -> MINUS INT .)
    GTE             reduce using rule 91 (negative -> MINUS INT .)
    LT              reduce using rule 91 (negative -> MINUS INT .)
    GT              reduce using rule 91 (negative -> MINUS INT .)
    DIF             reduce using rule 91 (negative -> MINUS INT .)
    COMMA           reduce using rule 91 (negative -> MINUS INT .)
    LCRLBRACKET     reduce using rule 91 (negative -> MINUS INT .)
    RPAREN          reduce using rule 91 (negative -> MINUS INT .)


state 53

    (6) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 88


state 54

    (14) line -> loop . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    loop                           shift and go to state 54
    line                           shift and go to state 89
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 55

    (15) line -> for . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    for                            shift and go to state 55
    line                           shift and go to state 90
    loop                           shift and go to state 54
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 56

    (16) line -> while . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    while                          shift and go to state 56
    line                           shift and go to state 91
    loop                           shift and go to state 54
    for                            shift and go to state 55
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 57

    (17) line -> if . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    if                             shift and go to state 57
    line                           shift and go to state 92
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 58

    (18) line -> let . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    let                            shift and go to state 58
    line                           shift and go to state 93
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 59

    (19) line -> move . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    move                           shift and go to state 59
    line                           shift and go to state 94
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 60

    (20) line -> moveList . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    moveList                       shift and go to state 60
    line                           shift and go to state 95
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 61

    (21) line -> delay . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    delay                          shift and go to state 61
    line                           shift and go to state 96
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 62

    (22) line -> println . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    println                        shift and go to state 62
    line                           shift and go to state 97
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 63

    (23) line -> break . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    break                          shift and go to state 63
    line                           shift and go to state 98
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 64

    (24) line -> declaration . line
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    declaration                    shift and go to state 64
    line                           shift and go to state 99
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    empty                          shift and go to state 65

state 65

    (25) line -> empty . empty
    (96) empty -> .

    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 100

state 66

    (35) loop -> LOOP . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 101


state 67

    (36) for -> FOR . ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> FOR . ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    ID              shift and go to state 102


state 68

    (26) declaration -> ID . LPAREN params RPAREN SEMICOLON

    LPAREN          shift and go to state 103


state 69

    (38) while -> WHILE . LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> WHILE . TRUE LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 104
    TRUE            shift and go to state 105


state 70

    (61) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (72) expression -> . INT
    (73) expression -> . TRUE
    (74) expression -> . FALSE
    (75) expression -> . opera
    (76) expression -> . ID
    (77) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    ID              shift and go to state 111
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    expression                     shift and go to state 106
    opera                          shift and go to state 110
    negative                       shift and go to state 112

state 71

    (40) move -> MOVE . LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> MOVE . LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    LPAREN          shift and go to state 113


state 72

    (44) delay -> DELAY . LPAREN INT COMMA STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 114


state 73

    (48) println -> PRINT . EXPR LPAREN args RPAREN SEMICOLON

    EXPR            shift and go to state 115


state 74

    (95) break -> BREAK .

    LOOP            reduce using rule 95 (break -> BREAK .)
    FOR             reduce using rule 95 (break -> BREAK .)
    WHILE           reduce using rule 95 (break -> BREAK .)
    IF              reduce using rule 95 (break -> BREAK .)
    LET             reduce using rule 95 (break -> BREAK .)
    MOVE            reduce using rule 95 (break -> BREAK .)
    DELAY           reduce using rule 95 (break -> BREAK .)
    PRINT           reduce using rule 95 (break -> BREAK .)
    BREAK           reduce using rule 95 (break -> BREAK .)
    ID              reduce using rule 95 (break -> BREAK .)
    RCRLBRACKET     reduce using rule 95 (break -> BREAK .)
    RETURN          reduce using rule 95 (break -> BREAK .)


state 75

    (33) arg -> COMMA params .

    RPAREN          reduce using rule 33 (arg -> COMMA params .)


state 76

    (34) arg -> empty empty .

    RPAREN          reduce using rule 34 (arg -> empty empty .)


state 77

    (9) function -> FN ID LPAREN params RPAREN funbody . LCRLBRACKET line end RCRLBRACKET

    LCRLBRACKET     shift and go to state 116


state 78

    (8) prodbody -> LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 117
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 79

    (7) procedure -> FN ID LPAREN params RPAREN prodbody .

    FN              reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LET             reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    $end            reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)


state 80

    (10) funbody -> ARROW . output
    (11) output -> . INTEGER
    (12) output -> . BOOLEAN

    INTEGER         shift and go to state 119
    BOOLEAN         shift and go to state 120

    output                         shift and go to state 118

state 81

    (27) declaration2 -> ID LPAREN params . RPAREN

    RPAREN          shift and go to state 121


state 82

    (81) opera -> OPERA LPAREN operator . COMMA operand COMMA operand RPAREN

    COMMA           shift and go to state 122


state 83

    (82) operator -> PLUS .

    COMMA           reduce using rule 82 (operator -> PLUS .)


state 84

    (83) operator -> MINUS .

    COMMA           reduce using rule 83 (operator -> MINUS .)


state 85

    (84) operator -> DIVIDE .

    COMMA           reduce using rule 84 (operator -> DIVIDE .)


state 86

    (85) operator -> ASTR .

    COMMA           reduce using rule 85 (operator -> ASTR .)


state 87

    (86) operator -> TIMES .

    COMMA           reduce using rule 86 (operator -> TIMES .)


state 88

    (6) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 6 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 6 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 6 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)


state 89

    (14) line -> loop line .

    RCRLBRACKET     reduce using rule 14 (line -> loop line .)
    RETURN          reduce using rule 14 (line -> loop line .)


state 90

    (15) line -> for line .

    RCRLBRACKET     reduce using rule 15 (line -> for line .)
    RETURN          reduce using rule 15 (line -> for line .)


state 91

    (16) line -> while line .

    RCRLBRACKET     reduce using rule 16 (line -> while line .)
    RETURN          reduce using rule 16 (line -> while line .)


state 92

    (17) line -> if line .

    RCRLBRACKET     reduce using rule 17 (line -> if line .)
    RETURN          reduce using rule 17 (line -> if line .)


state 93

    (18) line -> let line .

    RCRLBRACKET     reduce using rule 18 (line -> let line .)
    RETURN          reduce using rule 18 (line -> let line .)


state 94

    (19) line -> move line .

    RCRLBRACKET     reduce using rule 19 (line -> move line .)
    RETURN          reduce using rule 19 (line -> move line .)


state 95

    (20) line -> moveList line .

    RCRLBRACKET     reduce using rule 20 (line -> moveList line .)
    RETURN          reduce using rule 20 (line -> moveList line .)


state 96

    (21) line -> delay line .

    RCRLBRACKET     reduce using rule 21 (line -> delay line .)
    RETURN          reduce using rule 21 (line -> delay line .)


state 97

    (22) line -> println line .

    RCRLBRACKET     reduce using rule 22 (line -> println line .)
    RETURN          reduce using rule 22 (line -> println line .)


state 98

    (23) line -> break line .

    RCRLBRACKET     reduce using rule 23 (line -> break line .)
    RETURN          reduce using rule 23 (line -> break line .)


state 99

    (24) line -> declaration line .

    RCRLBRACKET     reduce using rule 24 (line -> declaration line .)
    RETURN          reduce using rule 24 (line -> declaration line .)


state 100

    (25) line -> empty empty .

    RCRLBRACKET     reduce using rule 25 (line -> empty empty .)
    RETURN          reduce using rule 25 (line -> empty empty .)


state 101

    (35) loop -> LOOP LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 123
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 102

    (36) for -> FOR ID . IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> FOR ID . IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    IN              shift and go to state 124


state 103

    (26) declaration -> ID LPAREN . params RPAREN SEMICOLON
    (28) params -> . ID arg
    (29) params -> . INT arg
    (30) params -> . TRUE arg
    (31) params -> . FALSE arg
    (32) params -> . empty empty
    (96) empty -> .

    ID              shift and go to state 21
    INT             shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    RPAREN          reduce using rule 96 (empty -> .)

    params                         shift and go to state 125
    empty                          shift and go to state 26

state 104

    (38) while -> WHILE LPAREN . expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (72) expression -> . INT
    (73) expression -> . TRUE
    (74) expression -> . FALSE
    (75) expression -> . opera
    (76) expression -> . ID
    (77) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    ID              shift and go to state 111
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    expression                     shift and go to state 126
    opera                          shift and go to state 110
    negative                       shift and go to state 112

state 105

    (39) while -> WHILE TRUE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 127


state 106

    (61) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (66) compare -> . EQEQ
    (67) compare -> . LTE
    (68) compare -> . GTE
    (69) compare -> . LT
    (70) compare -> . GT
    (71) compare -> . DIF

    EQEQ            shift and go to state 129
    LTE             shift and go to state 130
    GTE             shift and go to state 131
    LT              shift and go to state 132
    GT              shift and go to state 133
    DIF             shift and go to state 134

    compare                        shift and go to state 128

state 107

    (72) expression -> INT .

    EQEQ            reduce using rule 72 (expression -> INT .)
    LTE             reduce using rule 72 (expression -> INT .)
    GTE             reduce using rule 72 (expression -> INT .)
    LT              reduce using rule 72 (expression -> INT .)
    GT              reduce using rule 72 (expression -> INT .)
    DIF             reduce using rule 72 (expression -> INT .)
    LCRLBRACKET     reduce using rule 72 (expression -> INT .)
    RPAREN          reduce using rule 72 (expression -> INT .)
    SEMICOLON       reduce using rule 72 (expression -> INT .)


state 108

    (73) expression -> TRUE .

    EQEQ            reduce using rule 73 (expression -> TRUE .)
    LTE             reduce using rule 73 (expression -> TRUE .)
    GTE             reduce using rule 73 (expression -> TRUE .)
    LT              reduce using rule 73 (expression -> TRUE .)
    GT              reduce using rule 73 (expression -> TRUE .)
    DIF             reduce using rule 73 (expression -> TRUE .)
    LCRLBRACKET     reduce using rule 73 (expression -> TRUE .)
    RPAREN          reduce using rule 73 (expression -> TRUE .)
    SEMICOLON       reduce using rule 73 (expression -> TRUE .)


state 109

    (74) expression -> FALSE .

    EQEQ            reduce using rule 74 (expression -> FALSE .)
    LTE             reduce using rule 74 (expression -> FALSE .)
    GTE             reduce using rule 74 (expression -> FALSE .)
    LT              reduce using rule 74 (expression -> FALSE .)
    GT              reduce using rule 74 (expression -> FALSE .)
    DIF             reduce using rule 74 (expression -> FALSE .)
    LCRLBRACKET     reduce using rule 74 (expression -> FALSE .)
    RPAREN          reduce using rule 74 (expression -> FALSE .)
    SEMICOLON       reduce using rule 74 (expression -> FALSE .)


state 110

    (75) expression -> opera .

    EQEQ            reduce using rule 75 (expression -> opera .)
    LTE             reduce using rule 75 (expression -> opera .)
    GTE             reduce using rule 75 (expression -> opera .)
    LT              reduce using rule 75 (expression -> opera .)
    GT              reduce using rule 75 (expression -> opera .)
    DIF             reduce using rule 75 (expression -> opera .)
    LCRLBRACKET     reduce using rule 75 (expression -> opera .)
    RPAREN          reduce using rule 75 (expression -> opera .)
    SEMICOLON       reduce using rule 75 (expression -> opera .)


state 111

    (76) expression -> ID .

    EQEQ            reduce using rule 76 (expression -> ID .)
    LTE             reduce using rule 76 (expression -> ID .)
    GTE             reduce using rule 76 (expression -> ID .)
    LT              reduce using rule 76 (expression -> ID .)
    GT              reduce using rule 76 (expression -> ID .)
    DIF             reduce using rule 76 (expression -> ID .)
    LCRLBRACKET     reduce using rule 76 (expression -> ID .)
    RPAREN          reduce using rule 76 (expression -> ID .)
    SEMICOLON       reduce using rule 76 (expression -> ID .)


state 112

    (77) expression -> negative .

    EQEQ            reduce using rule 77 (expression -> negative .)
    LTE             reduce using rule 77 (expression -> negative .)
    GTE             reduce using rule 77 (expression -> negative .)
    LT              reduce using rule 77 (expression -> negative .)
    GT              reduce using rule 77 (expression -> negative .)
    DIF             reduce using rule 77 (expression -> negative .)
    LCRLBRACKET     reduce using rule 77 (expression -> negative .)
    RPAREN          reduce using rule 77 (expression -> negative .)
    SEMICOLON       reduce using rule 77 (expression -> negative .)


state 113

    (40) move -> MOVE LPAREN . STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> MOVE LPAREN . LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    STRING          shift and go to state 135
    LSQRBRACKET     shift and go to state 136


state 114

    (44) delay -> DELAY LPAREN . INT COMMA STRING RPAREN SEMICOLON

    INT             shift and go to state 137


state 115

    (48) println -> PRINT EXPR . LPAREN args RPAREN SEMICOLON

    LPAREN          shift and go to state 138


state 116

    (9) function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET . line end RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RETURN          reduce using rule 96 (empty -> .)

    line                           shift and go to state 139
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 117

    (8) prodbody -> LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 140


state 118

    (10) funbody -> ARROW output .

    LCRLBRACKET     reduce using rule 10 (funbody -> ARROW output .)


state 119

    (11) output -> INTEGER .

    LCRLBRACKET     reduce using rule 11 (output -> INTEGER .)


state 120

    (12) output -> BOOLEAN .

    LCRLBRACKET     reduce using rule 12 (output -> BOOLEAN .)


state 121

    (27) declaration2 -> ID LPAREN params RPAREN .

    SEMICOLON       reduce using rule 27 (declaration2 -> ID LPAREN params RPAREN .)


state 122

    (81) opera -> OPERA LPAREN operator COMMA . operand COMMA operand RPAREN
    (87) operand -> . INT
    (88) operand -> . opera
    (89) operand -> . ID
    (90) operand -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 31
    ID              shift and go to state 142
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    operand                        shift and go to state 141
    opera                          shift and go to state 32
    negative                       shift and go to state 33

state 123

    (35) loop -> LOOP LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 143


state 124

    (36) for -> FOR ID IN . INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> FOR ID IN . INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 144


state 125

    (26) declaration -> ID LPAREN params . RPAREN SEMICOLON

    RPAREN          shift and go to state 145


state 126

    (38) while -> WHILE LPAREN expression . compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (66) compare -> . EQEQ
    (67) compare -> . LTE
    (68) compare -> . GTE
    (69) compare -> . LT
    (70) compare -> . GT
    (71) compare -> . DIF

    EQEQ            shift and go to state 129
    LTE             shift and go to state 130
    GTE             shift and go to state 131
    LT              shift and go to state 132
    GT              shift and go to state 133
    DIF             shift and go to state 134

    compare                        shift and go to state 146

state 127

    (39) while -> WHILE TRUE LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 147
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 128

    (61) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (72) expression -> . INT
    (73) expression -> . TRUE
    (74) expression -> . FALSE
    (75) expression -> . opera
    (76) expression -> . ID
    (77) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    ID              shift and go to state 111
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    expression                     shift and go to state 148
    opera                          shift and go to state 110
    negative                       shift and go to state 112

state 129

    (66) compare -> EQEQ .

    INT             reduce using rule 66 (compare -> EQEQ .)
    TRUE            reduce using rule 66 (compare -> EQEQ .)
    FALSE           reduce using rule 66 (compare -> EQEQ .)
    ID              reduce using rule 66 (compare -> EQEQ .)
    OPERA           reduce using rule 66 (compare -> EQEQ .)
    MINUS           reduce using rule 66 (compare -> EQEQ .)


state 130

    (67) compare -> LTE .

    INT             reduce using rule 67 (compare -> LTE .)
    TRUE            reduce using rule 67 (compare -> LTE .)
    FALSE           reduce using rule 67 (compare -> LTE .)
    ID              reduce using rule 67 (compare -> LTE .)
    OPERA           reduce using rule 67 (compare -> LTE .)
    MINUS           reduce using rule 67 (compare -> LTE .)


state 131

    (68) compare -> GTE .

    INT             reduce using rule 68 (compare -> GTE .)
    TRUE            reduce using rule 68 (compare -> GTE .)
    FALSE           reduce using rule 68 (compare -> GTE .)
    ID              reduce using rule 68 (compare -> GTE .)
    OPERA           reduce using rule 68 (compare -> GTE .)
    MINUS           reduce using rule 68 (compare -> GTE .)


state 132

    (69) compare -> LT .

    INT             reduce using rule 69 (compare -> LT .)
    TRUE            reduce using rule 69 (compare -> LT .)
    FALSE           reduce using rule 69 (compare -> LT .)
    ID              reduce using rule 69 (compare -> LT .)
    OPERA           reduce using rule 69 (compare -> LT .)
    MINUS           reduce using rule 69 (compare -> LT .)


state 133

    (70) compare -> GT .

    INT             reduce using rule 70 (compare -> GT .)
    TRUE            reduce using rule 70 (compare -> GT .)
    FALSE           reduce using rule 70 (compare -> GT .)
    ID              reduce using rule 70 (compare -> GT .)
    OPERA           reduce using rule 70 (compare -> GT .)
    MINUS           reduce using rule 70 (compare -> GT .)


state 134

    (71) compare -> DIF .

    INT             reduce using rule 71 (compare -> DIF .)
    TRUE            reduce using rule 71 (compare -> DIF .)
    FALSE           reduce using rule 71 (compare -> DIF .)
    ID              reduce using rule 71 (compare -> DIF .)
    OPERA           reduce using rule 71 (compare -> DIF .)
    MINUS           reduce using rule 71 (compare -> DIF .)


state 135

    (40) move -> MOVE LPAREN STRING . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 149


state 136

    (41) moveList -> MOVE LPAREN LSQRBRACKET . fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (42) fingerList -> . STRING COMMA STRING
    (43) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 151

    fingerList                     shift and go to state 150

state 137

    (44) delay -> DELAY LPAREN INT . COMMA STRING RPAREN SEMICOLON

    COMMA           shift and go to state 152


state 138

    (48) println -> PRINT EXPR LPAREN . args RPAREN SEMICOLON
    (49) args -> . INT body
    (50) args -> . ID body
    (51) args -> . opera body
    (52) args -> . TRUE body
    (53) args -> . FALSE body
    (54) args -> . STRING body
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 154
    ID              shift and go to state 155
    TRUE            shift and go to state 157
    FALSE           shift and go to state 158
    STRING          shift and go to state 159
    OPERA           shift and go to state 36

    args                           shift and go to state 153
    opera                          shift and go to state 156

state 139

    (9) function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET line . end RCRLBRACKET
    (13) end -> . RETURN expression SEMICOLON

    RETURN          shift and go to state 161

    end                            shift and go to state 160

state 140

    (8) prodbody -> LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)


state 141

    (81) opera -> OPERA LPAREN operator COMMA operand . COMMA operand RPAREN

    COMMA           shift and go to state 162


state 142

    (89) operand -> ID .

    COMMA           reduce using rule 89 (operand -> ID .)
    RPAREN          reduce using rule 89 (operand -> ID .)


state 143

    (35) loop -> LOOP LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 35 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)


state 144

    (36) for -> FOR ID IN INT . DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> FOR ID IN INT . DOTDOT INT LCRLBRACKET line RCRLBRACKET

    DOTDOTEQ        shift and go to state 163
    DOTDOT          shift and go to state 164


state 145

    (26) declaration -> ID LPAREN params RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 165


state 146

    (38) while -> WHILE LPAREN expression compare . expression RPAREN LCRLBRACKET line RCRLBRACKET
    (72) expression -> . INT
    (73) expression -> . TRUE
    (74) expression -> . FALSE
    (75) expression -> . opera
    (76) expression -> . ID
    (77) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    ID              shift and go to state 111
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    expression                     shift and go to state 166
    opera                          shift and go to state 110
    negative                       shift and go to state 112

state 147

    (39) while -> WHILE TRUE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 167


state 148

    (61) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (62) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 168


state 149

    (40) move -> MOVE LPAREN STRING COMMA . bool RPAREN SEMICOLON
    (92) bool -> . TRUE
    (93) bool -> . FALSE
    (94) bool -> . ID

    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 170

    bool                           shift and go to state 169

state 150

    (41) moveList -> MOVE LPAREN LSQRBRACKET fingerList . RSQRBRACKET COMMA bool RPAREN SEMICOLON

    RSQRBRACKET     shift and go to state 171


state 151

    (42) fingerList -> STRING . COMMA STRING
    (43) fingerList -> STRING . COMMA fingerList

    COMMA           shift and go to state 172


state 152

    (44) delay -> DELAY LPAREN INT COMMA . STRING RPAREN SEMICOLON

    STRING          shift and go to state 173


state 153

    (48) println -> PRINT EXPR LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 174


state 154

    (49) args -> INT . body
    (55) body -> . COMMA args
    (56) body -> . COMMA body
    (57) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 176
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 175
    empty                          shift and go to state 177

state 155

    (50) args -> ID . body
    (55) body -> . COMMA args
    (56) body -> . COMMA body
    (57) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 176
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 178
    empty                          shift and go to state 177

state 156

    (51) args -> opera . body
    (55) body -> . COMMA args
    (56) body -> . COMMA body
    (57) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 176
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 179
    empty                          shift and go to state 177

state 157

    (52) args -> TRUE . body
    (55) body -> . COMMA args
    (56) body -> . COMMA body
    (57) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 176
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 180
    empty                          shift and go to state 177

state 158

    (53) args -> FALSE . body
    (55) body -> . COMMA args
    (56) body -> . COMMA body
    (57) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 176
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 181
    empty                          shift and go to state 177

state 159

    (54) args -> STRING . body
    (55) body -> . COMMA args
    (56) body -> . COMMA body
    (57) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 176
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 182
    empty                          shift and go to state 177

state 160

    (9) function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET line end . RCRLBRACKET

    RCRLBRACKET     shift and go to state 183


state 161

    (13) end -> RETURN . expression SEMICOLON
    (72) expression -> . INT
    (73) expression -> . TRUE
    (74) expression -> . FALSE
    (75) expression -> . opera
    (76) expression -> . ID
    (77) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    ID              shift and go to state 111
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    expression                     shift and go to state 184
    opera                          shift and go to state 110
    negative                       shift and go to state 112

state 162

    (81) opera -> OPERA LPAREN operator COMMA operand COMMA . operand RPAREN
    (87) operand -> . INT
    (88) operand -> . opera
    (89) operand -> . ID
    (90) operand -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 31
    ID              shift and go to state 142
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    operand                        shift and go to state 185
    opera                          shift and go to state 32
    negative                       shift and go to state 33

state 163

    (36) for -> FOR ID IN INT DOTDOTEQ . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 186


state 164

    (37) for -> FOR ID IN INT DOTDOT . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 187


state 165

    (26) declaration -> ID LPAREN params RPAREN SEMICOLON .

    LOOP            reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    FOR             reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    IF              reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    LET             reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    MOVE            reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    DELAY           reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    PRINT           reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    BREAK           reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    ID              reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    RETURN          reduce using rule 26 (declaration -> ID LPAREN params RPAREN SEMICOLON .)


state 166

    (38) while -> WHILE LPAREN expression compare expression . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 188


state 167

    (39) while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 39 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)


state 168

    (61) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (62) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 189
    empty                          shift and go to state 65
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64

state 169

    (40) move -> MOVE LPAREN STRING COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 190


state 170

    (94) bool -> ID .

    RPAREN          reduce using rule 94 (bool -> ID .)


state 171

    (41) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 191


state 172

    (42) fingerList -> STRING COMMA . STRING
    (43) fingerList -> STRING COMMA . fingerList
    (42) fingerList -> . STRING COMMA STRING
    (43) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 192

    fingerList                     shift and go to state 193

state 173

    (44) delay -> DELAY LPAREN INT COMMA STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 194


state 174

    (48) println -> PRINT EXPR LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 195


state 175

    (49) args -> INT body .

    RPAREN          reduce using rule 49 (args -> INT body .)


state 176

    (55) body -> COMMA . args
    (56) body -> COMMA . body
    (49) args -> . INT body
    (50) args -> . ID body
    (51) args -> . opera body
    (52) args -> . TRUE body
    (53) args -> . FALSE body
    (54) args -> . STRING body
    (55) body -> . COMMA args
    (56) body -> . COMMA body
    (57) body -> . empty empty
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (96) empty -> .

    INT             shift and go to state 154
    ID              shift and go to state 155
    TRUE            shift and go to state 157
    FALSE           shift and go to state 158
    STRING          shift and go to state 159
    COMMA           shift and go to state 176
    OPERA           shift and go to state 36
    RPAREN          reduce using rule 96 (empty -> .)

    args                           shift and go to state 196
    body                           shift and go to state 197
    opera                          shift and go to state 156
    empty                          shift and go to state 177

state 177

    (57) body -> empty . empty
    (96) empty -> .

    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 198

state 178

    (50) args -> ID body .

    RPAREN          reduce using rule 50 (args -> ID body .)


state 179

    (51) args -> opera body .

    RPAREN          reduce using rule 51 (args -> opera body .)


state 180

    (52) args -> TRUE body .

    RPAREN          reduce using rule 52 (args -> TRUE body .)


state 181

    (53) args -> FALSE body .

    RPAREN          reduce using rule 53 (args -> FALSE body .)


state 182

    (54) args -> STRING body .

    RPAREN          reduce using rule 54 (args -> STRING body .)


state 183

    (9) function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET .

    FN              reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET .)
    LET             reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET .)
    $end            reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody LCRLBRACKET line end RCRLBRACKET .)


state 184

    (13) end -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 199


state 185

    (81) opera -> OPERA LPAREN operator COMMA operand COMMA operand . RPAREN

    RPAREN          shift and go to state 200


state 186

    (36) for -> FOR ID IN INT DOTDOTEQ INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 201


state 187

    (37) for -> FOR ID IN INT DOTDOT INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 202


state 188

    (38) while -> WHILE LPAREN expression compare expression RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 203


state 189

    (61) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (62) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 204


state 190

    (40) move -> MOVE LPAREN STRING COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 205


state 191

    (41) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA . bool RPAREN SEMICOLON
    (92) bool -> . TRUE
    (93) bool -> . FALSE
    (94) bool -> . ID

    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 170

    bool                           shift and go to state 206

state 192

    (42) fingerList -> STRING COMMA STRING .
    (42) fingerList -> STRING . COMMA STRING
    (43) fingerList -> STRING . COMMA fingerList

    RSQRBRACKET     reduce using rule 42 (fingerList -> STRING COMMA STRING .)
    COMMA           shift and go to state 172


state 193

    (43) fingerList -> STRING COMMA fingerList .

    RSQRBRACKET     reduce using rule 43 (fingerList -> STRING COMMA fingerList .)


state 194

    (44) delay -> DELAY LPAREN INT COMMA STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 207


state 195

    (48) println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .

    LOOP            reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    LET             reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    MOVE            reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    DELAY           reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    PRINT           reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    BREAK           reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    ID              reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 48 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)


state 196

    (55) body -> COMMA args .

    RPAREN          reduce using rule 55 (body -> COMMA args .)


state 197

    (56) body -> COMMA body .

    RPAREN          reduce using rule 56 (body -> COMMA body .)


state 198

    (57) body -> empty empty .

    RPAREN          reduce using rule 57 (body -> empty empty .)


state 199

    (13) end -> RETURN expression SEMICOLON .

    RCRLBRACKET     reduce using rule 13 (end -> RETURN expression SEMICOLON .)


state 200

    (81) opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .

    SEMICOLON       reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    EQEQ            reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LTE             reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GTE             reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LT              reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GT              reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    DIF             reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    COMMA           reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LCRLBRACKET     reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    RPAREN          reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)


state 201

    (36) for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 208
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 202

    (37) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 209
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 203

    (38) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 210
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 204

    (61) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (62) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (96) empty -> .
    (59) elseiforelse -> . elseif
    (60) elseiforelse -> . else
    (63) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (64) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (65) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    WHILE           reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    LET             reduce using rule 96 (empty -> .)
    MOVE            reduce using rule 96 (empty -> .)
    DELAY           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)
    ELSEIF          shift and go to state 215
    ELSE            shift and go to state 216

    empty                          shift and go to state 211
    elseiforelse                   shift and go to state 212
    elseif                         shift and go to state 213
    else                           shift and go to state 214

state 205

    (40) move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    ID              reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 40 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)


state 206

    (41) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 217


state 207

    (44) delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .

    LOOP            reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    IF              reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    LET             reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    MOVE            reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    DELAY           reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    PRINT           reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    BREAK           reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    ID              reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 44 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)


state 208

    (36) for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 218


state 209

    (37) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 219


state 210

    (38) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 220


state 211

    (61) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    ID              reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 61 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 212

    (62) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    ID              reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)


state 213

    (59) elseiforelse -> elseif .

    LOOP            reduce using rule 59 (elseiforelse -> elseif .)
    FOR             reduce using rule 59 (elseiforelse -> elseif .)
    WHILE           reduce using rule 59 (elseiforelse -> elseif .)
    IF              reduce using rule 59 (elseiforelse -> elseif .)
    LET             reduce using rule 59 (elseiforelse -> elseif .)
    MOVE            reduce using rule 59 (elseiforelse -> elseif .)
    DELAY           reduce using rule 59 (elseiforelse -> elseif .)
    PRINT           reduce using rule 59 (elseiforelse -> elseif .)
    BREAK           reduce using rule 59 (elseiforelse -> elseif .)
    ID              reduce using rule 59 (elseiforelse -> elseif .)
    RCRLBRACKET     reduce using rule 59 (elseiforelse -> elseif .)
    RETURN          reduce using rule 59 (elseiforelse -> elseif .)


state 214

    (60) elseiforelse -> else .

    LOOP            reduce using rule 60 (elseiforelse -> else .)
    FOR             reduce using rule 60 (elseiforelse -> else .)
    WHILE           reduce using rule 60 (elseiforelse -> else .)
    IF              reduce using rule 60 (elseiforelse -> else .)
    LET             reduce using rule 60 (elseiforelse -> else .)
    MOVE            reduce using rule 60 (elseiforelse -> else .)
    DELAY           reduce using rule 60 (elseiforelse -> else .)
    PRINT           reduce using rule 60 (elseiforelse -> else .)
    BREAK           reduce using rule 60 (elseiforelse -> else .)
    ID              reduce using rule 60 (elseiforelse -> else .)
    RCRLBRACKET     reduce using rule 60 (elseiforelse -> else .)
    RETURN          reduce using rule 60 (elseiforelse -> else .)


state 215

    (63) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (64) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (72) expression -> . INT
    (73) expression -> . TRUE
    (74) expression -> . FALSE
    (75) expression -> . opera
    (76) expression -> . ID
    (77) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    ID              shift and go to state 111
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    expression                     shift and go to state 221
    opera                          shift and go to state 110
    negative                       shift and go to state 112

state 216

    (65) else -> ELSE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 222


state 217

    (41) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 223


state 218

    (36) for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 36 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)


state 219

    (37) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 37 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)


state 220

    (38) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 38 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)


state 221

    (63) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (64) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (66) compare -> . EQEQ
    (67) compare -> . LTE
    (68) compare -> . GTE
    (69) compare -> . LT
    (70) compare -> . GT
    (71) compare -> . DIF

    EQEQ            shift and go to state 129
    LTE             shift and go to state 130
    GTE             shift and go to state 131
    LT              shift and go to state 132
    GT              shift and go to state 133
    DIF             shift and go to state 134

    compare                        shift and go to state 224

state 222

    (65) else -> ELSE LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 225
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 223

    (41) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    ID              reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 41 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)


state 224

    (63) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (64) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (72) expression -> . INT
    (73) expression -> . TRUE
    (74) expression -> . FALSE
    (75) expression -> . opera
    (76) expression -> . ID
    (77) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    ID              shift and go to state 111
    OPERA           shift and go to state 36
    MINUS           shift and go to state 37

    expression                     shift and go to state 226
    opera                          shift and go to state 110
    negative                       shift and go to state 112

state 225

    (65) else -> ELSE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 227


state 226

    (63) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (64) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 228


state 227

    (65) else -> ELSE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 65 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)


state 228

    (63) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (14) line -> . loop line
    (15) line -> . for line
    (16) line -> . while line
    (17) line -> . if line
    (18) line -> . let line
    (19) line -> . move line
    (20) line -> . moveList line
    (21) line -> . delay line
    (22) line -> . println line
    (23) line -> . break line
    (24) line -> . declaration line
    (25) line -> . empty empty
    (35) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (36) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (37) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (38) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (61) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (78) let -> . LET ID ASSIGN operand SEMICOLON
    (79) let -> . LET ID ASSIGN bool SEMICOLON
    (80) let -> . LET ID ASSIGN declaration2 SEMICOLON
    (40) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (41) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (44) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (48) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (26) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FOR             shift and go to state 67
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 68
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 229
    empty                          shift and go to state 65
    loop                           shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64

state 229

    (63) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 230


state 230

    (63) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (96) empty -> .
    (59) elseiforelse -> . elseif
    (60) elseiforelse -> . else
    (63) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (64) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (65) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    WHILE           reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    LET             reduce using rule 96 (empty -> .)
    MOVE            reduce using rule 96 (empty -> .)
    DELAY           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)
    ELSEIF          shift and go to state 215
    ELSE            shift and go to state 216

    empty                          shift and go to state 231
    elseiforelse                   shift and go to state 232
    elseif                         shift and go to state 213
    else                           shift and go to state 214

state 231

    (63) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    ID              reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 63 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 232

    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    ID              reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 27 resolved using rule (operand -> ID)
WARNING: rejected rule (bool -> ID) in state 27
