Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    RANGE
    WRONG_ID

Grammar

Rule 0     S' -> root
Rule 1     root -> main root
Rule 2     root -> function root
Rule 3     root -> procedure root
Rule 4     root -> let root
Rule 5     root -> empty empty
Rule 6     main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
Rule 7     procedure -> FN ID LPAREN params RPAREN prodbody
Rule 8     prodbody -> LCRLBRACKET line RCRLBRACKET
Rule 9     function -> FN ID LPAREN params RPAREN funbody
Rule 10    funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET
Rule 11    output -> INTEGER
Rule 12    output -> BOOLEAN
Rule 13    end -> RETURN expression SEMICOLON
Rule 14    line -> loop line
Rule 15    line -> function line
Rule 16    line -> procedure line
Rule 17    line -> for line
Rule 18    line -> while line
Rule 19    line -> if line
Rule 20    line -> let line
Rule 21    line -> move line
Rule 22    line -> moveList line
Rule 23    line -> delay line
Rule 24    line -> println line
Rule 25    line -> break line
Rule 26    line -> declaration line
Rule 27    line -> empty empty
Rule 28    declaration -> ID LPAREN params RPAREN SEMICOLON
Rule 29    params -> ID arg
Rule 30    params -> INT arg
Rule 31    params -> TRUE arg
Rule 32    params -> FALSE arg
Rule 33    params -> empty empty
Rule 34    arg -> COMMA params
Rule 35    arg -> empty empty
Rule 36    loop -> LOOP LCRLBRACKET line RCRLBRACKET
Rule 37    for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
Rule 38    for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
Rule 39    while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
Rule 40    while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET
Rule 41    move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
Rule 42    moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
Rule 43    fingerList -> STRING COMMA STRING
Rule 44    fingerList -> STRING COMMA fingerList
Rule 45    delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
Rule 46    unit -> QUOT MIN QUOT
Rule 47    unit -> QUOT MIL QUOT
Rule 48    unit -> QUOT SEG QUOT
Rule 49    println -> PRINT EXPR LPAREN args RPAREN SEMICOLON
Rule 50    args -> INT body
Rule 51    args -> ID body
Rule 52    args -> opera body
Rule 53    args -> TRUE body
Rule 54    args -> FALSE body
Rule 55    args -> STRING body
Rule 56    body -> COMMA args
Rule 57    body -> COMMA body
Rule 58    body -> empty empty
Rule 59    text -> QUOT ID QUOT
Rule 60    elseiforelse -> elseif
Rule 61    elseiforelse -> else
Rule 62    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 63    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 64    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 65    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 66    else -> ELSE LCRLBRACKET line RCRLBRACKET
Rule 67    compare -> EQEQ
Rule 68    compare -> LTE
Rule 69    compare -> GTE
Rule 70    compare -> LT
Rule 71    compare -> GT
Rule 72    compare -> DIF
Rule 73    expression -> INT
Rule 74    expression -> TRUE
Rule 75    expression -> FALSE
Rule 76    expression -> opera
Rule 77    expression -> ID
Rule 78    expression -> negative
Rule 79    let -> LET ID ASSIGN operand SEMICOLON
Rule 80    let -> LET ID ASSIGN bool SEMICOLON
Rule 81    opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN
Rule 82    operator -> PLUS
Rule 83    operator -> MINUS
Rule 84    operator -> DIVIDE
Rule 85    operator -> ASTR
Rule 86    operator -> TIMES
Rule 87    operand -> INT
Rule 88    operand -> opera
Rule 89    operand -> ID
Rule 90    operand -> negative
Rule 91    negative -> MINUS INT
Rule 92    bool -> TRUE
Rule 93    bool -> FALSE
Rule 94    bool -> ID
Rule 95    break -> BREAK
Rule 96    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 10
ASSIGN               : 79 80
ASTR                 : 85
BOOLEAN              : 12
BREAK                : 95
COMMA                : 34 41 42 43 44 45 56 57 81 81
DELAY                : 45
DIF                  : 72
DIVIDE               : 84
DOTDOT               : 38
DOTDOTEQ             : 37
ELSE                 : 66
ELSEIF               : 64 65
EQEQ                 : 67
EXPR                 : 49
FALSE                : 32 54 75 93
FN                   : 6 7 9
FOR                  : 37 38
GT                   : 71
GTE                  : 69
ID                   : 7 9 28 29 37 38 51 59 77 79 80 89 94
IF                   : 62 63
IN                   : 37 38
INT                  : 30 37 37 38 38 45 50 73 87 91
INTEGER              : 11
LCRLBRACKET          : 6 8 10 36 37 38 39 40 62 63 64 65 66
LET                  : 79 80
LOOP                 : 36
LPAREN               : 6 7 9 28 39 41 42 45 49 81
LSQRBRACKET          : 42
LT                   : 70
LTE                  : 68
MAIN                 : 6
MIL                  : 47
MIN                  : 46
MINUS                : 83 91
MOVE                 : 41 42
OPERA                : 81
PLUS                 : 82
PRINT                : 49
QUOT                 : 46 46 47 47 48 48 59 59
RANGE                : 
RCRLBRACKET          : 6 8 10 36 37 38 39 40 62 63 64 65 66
RETURN               : 13
RPAREN               : 6 7 9 28 39 41 42 45 49 81
RSQRBRACKET          : 42
SEG                  : 48
SEMICOLON            : 13 28 41 42 45 49 79 80
STRING               : 41 43 43 44 45 55
TIMES                : 86
TRUE                 : 31 40 53 74 92
WHILE                : 39 40
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

arg                  : 29 30 31 32
args                 : 49 56
body                 : 50 51 52 53 54 55 57
bool                 : 41 42 80
break                : 25
compare              : 39 62 63 64 65
declaration          : 26
delay                : 23
else                 : 61
elseif               : 60
elseiforelse         : 63 65
empty                : 5 5 27 27 33 33 35 35 58 58 62 64
end                  : 10
expression           : 13 39 39 62 62 63 63 64 64 65 65
fingerList           : 42 44
for                  : 17
funbody              : 9
function             : 2 15
if                   : 19
let                  : 4 20
line                 : 6 8 10 14 15 16 17 18 19 20 21 22 23 24 25 26 36 37 38 39 40 62 63 64 65 66
loop                 : 14
main                 : 1
move                 : 21
moveList             : 22
negative             : 78 90
opera                : 52 76 88
operand              : 79 81 81
operator             : 81
output               : 10
params               : 7 9 28 34
println              : 24
procedure            : 3 16
prodbody             : 7
root                 : 1 2 3 4 0
text                 : 
unit                 : 
while                : 18

Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    root                           shift and go to state 1
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 1

    (0) S' -> root .



state 2

    (1) root -> main . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    main                           shift and go to state 2
    root                           shift and go to state 9
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) root -> function . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    function                       shift and go to state 3
    root                           shift and go to state 10
    main                           shift and go to state 2
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 4

    (3) root -> procedure . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    procedure                      shift and go to state 4
    root                           shift and go to state 11
    main                           shift and go to state 2
    function                       shift and go to state 3
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 5

    (4) root -> let . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (6) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (96) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 96 (empty -> .)

    let                            shift and go to state 5
    root                           shift and go to state 12
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    empty                          shift and go to state 6

state 6

    (5) root -> empty . empty
    (96) empty -> .

    $end            reduce using rule 96 (empty -> .)

    empty                          shift and go to state 13

state 7

    (6) main -> FN . MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (9) function -> FN . ID LPAREN params RPAREN funbody
    (7) procedure -> FN . ID LPAREN params RPAREN prodbody

    MAIN            shift and go to state 14
    ID              shift and go to state 15


state 8

    (79) let -> LET . ID ASSIGN operand SEMICOLON
    (80) let -> LET . ID ASSIGN bool SEMICOLON

    ID              shift and go to state 16


state 9

    (1) root -> main root .

    $end            reduce using rule 1 (root -> main root .)


state 10

    (2) root -> function root .

    $end            reduce using rule 2 (root -> function root .)


state 11

    (3) root -> procedure root .

    $end            reduce using rule 3 (root -> procedure root .)


state 12

    (4) root -> let root .

    $end            reduce using rule 4 (root -> let root .)


state 13

    (5) root -> empty empty .

    $end            reduce using rule 5 (root -> empty empty .)


state 14

    (6) main -> FN MAIN . LPAREN RPAREN LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 17


state 15

    (9) function -> FN ID . LPAREN params RPAREN funbody
    (7) procedure -> FN ID . LPAREN params RPAREN prodbody

    LPAREN          shift and go to state 18


state 16

    (79) let -> LET ID . ASSIGN operand SEMICOLON
    (80) let -> LET ID . ASSIGN bool SEMICOLON

    ASSIGN          shift and go to state 19


state 17

    (6) main -> FN MAIN LPAREN . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 20


state 18

    (9) function -> FN ID LPAREN . params RPAREN funbody
    (7) procedure -> FN ID LPAREN . params RPAREN prodbody
    (29) params -> . ID arg
    (30) params -> . INT arg
    (31) params -> . TRUE arg
    (32) params -> . FALSE arg
    (33) params -> . empty empty
    (96) empty -> .

    ID              shift and go to state 21
    INT             shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    RPAREN          reduce using rule 96 (empty -> .)

    params                         shift and go to state 22
    empty                          shift and go to state 26

state 19

    (79) let -> LET ID ASSIGN . operand SEMICOLON
    (80) let -> LET ID ASSIGN . bool SEMICOLON
    (87) operand -> . INT
    (88) operand -> . opera
    (89) operand -> . ID
    (90) operand -> . negative
    (92) bool -> . TRUE
    (93) bool -> . FALSE
    (94) bool -> . ID
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 30
    ID              shift and go to state 27
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    operand                        shift and go to state 28
    bool                           shift and go to state 29
    opera                          shift and go to state 31
    negative                       shift and go to state 32

state 20

    (6) main -> FN MAIN LPAREN RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 37


state 21

    (29) params -> ID . arg
    (34) arg -> . COMMA params
    (35) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 39
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 38
    empty                          shift and go to state 40

state 22

    (9) function -> FN ID LPAREN params . RPAREN funbody
    (7) procedure -> FN ID LPAREN params . RPAREN prodbody

    RPAREN          shift and go to state 41


state 23

    (30) params -> INT . arg
    (34) arg -> . COMMA params
    (35) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 39
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 42
    empty                          shift and go to state 40

state 24

    (31) params -> TRUE . arg
    (34) arg -> . COMMA params
    (35) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 39
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 43
    empty                          shift and go to state 40

state 25

    (32) params -> FALSE . arg
    (34) arg -> . COMMA params
    (35) arg -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 39
    RPAREN          reduce using rule 96 (empty -> .)

    arg                            shift and go to state 44
    empty                          shift and go to state 40

state 26

    (33) params -> empty . empty
    (96) empty -> .

    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 45

state 27

    (89) operand -> ID .
    (94) bool -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 89 (operand -> ID .)
    SEMICOLON       reduce using rule 89 (operand -> ID .)

  ! SEMICOLON       [ reduce using rule 94 (bool -> ID .) ]


state 28

    (79) let -> LET ID ASSIGN operand . SEMICOLON

    SEMICOLON       shift and go to state 46


state 29

    (80) let -> LET ID ASSIGN bool . SEMICOLON

    SEMICOLON       shift and go to state 47


state 30

    (87) operand -> INT .

    SEMICOLON       reduce using rule 87 (operand -> INT .)
    COMMA           reduce using rule 87 (operand -> INT .)
    RPAREN          reduce using rule 87 (operand -> INT .)


state 31

    (88) operand -> opera .

    SEMICOLON       reduce using rule 88 (operand -> opera .)
    COMMA           reduce using rule 88 (operand -> opera .)
    RPAREN          reduce using rule 88 (operand -> opera .)


state 32

    (90) operand -> negative .

    SEMICOLON       reduce using rule 90 (operand -> negative .)
    COMMA           reduce using rule 90 (operand -> negative .)
    RPAREN          reduce using rule 90 (operand -> negative .)


state 33

    (92) bool -> TRUE .

    SEMICOLON       reduce using rule 92 (bool -> TRUE .)
    RPAREN          reduce using rule 92 (bool -> TRUE .)


state 34

    (93) bool -> FALSE .

    SEMICOLON       reduce using rule 93 (bool -> FALSE .)
    RPAREN          reduce using rule 93 (bool -> FALSE .)


state 35

    (81) opera -> OPERA . LPAREN operator COMMA operand COMMA operand RPAREN

    LPAREN          shift and go to state 48


state 36

    (91) negative -> MINUS . INT

    INT             shift and go to state 49


state 37

    (6) main -> FN MAIN LPAREN RPAREN LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 51
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 38

    (29) params -> ID arg .

    RPAREN          reduce using rule 29 (params -> ID arg .)


state 39

    (34) arg -> COMMA . params
    (29) params -> . ID arg
    (30) params -> . INT arg
    (31) params -> . TRUE arg
    (32) params -> . FALSE arg
    (33) params -> . empty empty
    (96) empty -> .

    ID              shift and go to state 21
    INT             shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    RPAREN          reduce using rule 96 (empty -> .)

    params                         shift and go to state 75
    empty                          shift and go to state 26

state 40

    (35) arg -> empty . empty
    (96) empty -> .

    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 76

state 41

    (9) function -> FN ID LPAREN params RPAREN . funbody
    (7) procedure -> FN ID LPAREN params RPAREN . prodbody
    (10) funbody -> . ARROW output LCRLBRACKET line end RCRLBRACKET
    (8) prodbody -> . LCRLBRACKET line RCRLBRACKET

    ARROW           shift and go to state 79
    LCRLBRACKET     shift and go to state 80

    funbody                        shift and go to state 77
    prodbody                       shift and go to state 78

state 42

    (30) params -> INT arg .

    RPAREN          reduce using rule 30 (params -> INT arg .)


state 43

    (31) params -> TRUE arg .

    RPAREN          reduce using rule 31 (params -> TRUE arg .)


state 44

    (32) params -> FALSE arg .

    RPAREN          reduce using rule 32 (params -> FALSE arg .)


state 45

    (33) params -> empty empty .

    RPAREN          reduce using rule 33 (params -> empty empty .)


state 46

    (79) let -> LET ID ASSIGN operand SEMICOLON .

    FN              reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    LET             reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    $end            reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    LOOP            reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    FOR             reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    WHILE           reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    IF              reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    MOVE            reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    DELAY           reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    PRINT           reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    BREAK           reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    ID              reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    RCRLBRACKET     reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)
    RETURN          reduce using rule 79 (let -> LET ID ASSIGN operand SEMICOLON .)


state 47

    (80) let -> LET ID ASSIGN bool SEMICOLON .

    FN              reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    LET             reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    $end            reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    LOOP            reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    FOR             reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    WHILE           reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    IF              reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    MOVE            reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    DELAY           reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    PRINT           reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    BREAK           reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    ID              reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    RCRLBRACKET     reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)
    RETURN          reduce using rule 80 (let -> LET ID ASSIGN bool SEMICOLON .)


state 48

    (81) opera -> OPERA LPAREN . operator COMMA operand COMMA operand RPAREN
    (82) operator -> . PLUS
    (83) operator -> . MINUS
    (84) operator -> . DIVIDE
    (85) operator -> . ASTR
    (86) operator -> . TIMES

    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    DIVIDE          shift and go to state 84
    ASTR            shift and go to state 85
    TIMES           shift and go to state 86

    operator                       shift and go to state 81

state 49

    (91) negative -> MINUS INT .

    SEMICOLON       reduce using rule 91 (negative -> MINUS INT .)
    EQEQ            reduce using rule 91 (negative -> MINUS INT .)
    LTE             reduce using rule 91 (negative -> MINUS INT .)
    GTE             reduce using rule 91 (negative -> MINUS INT .)
    LT              reduce using rule 91 (negative -> MINUS INT .)
    GT              reduce using rule 91 (negative -> MINUS INT .)
    DIF             reduce using rule 91 (negative -> MINUS INT .)
    COMMA           reduce using rule 91 (negative -> MINUS INT .)
    LCRLBRACKET     reduce using rule 91 (negative -> MINUS INT .)
    RPAREN          reduce using rule 91 (negative -> MINUS INT .)


state 50

    (9) function -> FN . ID LPAREN params RPAREN funbody
    (7) procedure -> FN . ID LPAREN params RPAREN prodbody

    ID              shift and go to state 15


state 51

    (6) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 87


state 52

    (14) line -> loop . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    loop                           shift and go to state 52
    line                           shift and go to state 88
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 53

    (15) line -> function . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    function                       shift and go to state 53
    line                           shift and go to state 89
    loop                           shift and go to state 52
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 54

    (16) line -> procedure . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    procedure                      shift and go to state 54
    line                           shift and go to state 90
    loop                           shift and go to state 52
    function                       shift and go to state 53
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 55

    (17) line -> for . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    for                            shift and go to state 55
    line                           shift and go to state 91
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 56

    (18) line -> while . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    while                          shift and go to state 56
    line                           shift and go to state 92
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 57

    (19) line -> if . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    if                             shift and go to state 57
    line                           shift and go to state 93
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 58

    (20) line -> let . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    let                            shift and go to state 58
    line                           shift and go to state 94
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 59

    (21) line -> move . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    move                           shift and go to state 59
    line                           shift and go to state 95
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 60

    (22) line -> moveList . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    moveList                       shift and go to state 60
    line                           shift and go to state 96
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 61

    (23) line -> delay . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    delay                          shift and go to state 61
    line                           shift and go to state 97
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 62

    (24) line -> println . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    println                        shift and go to state 62
    line                           shift and go to state 98
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 63

    (25) line -> break . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    break                          shift and go to state 63
    line                           shift and go to state 99
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 64

    (26) line -> declaration . line
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    declaration                    shift and go to state 64
    line                           shift and go to state 100
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    empty                          shift and go to state 65

state 65

    (27) line -> empty . empty
    (96) empty -> .

    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 101

state 66

    (36) loop -> LOOP . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 102


state 67

    (28) declaration -> ID . LPAREN params RPAREN SEMICOLON

    LPAREN          shift and go to state 103


state 68

    (37) for -> FOR . ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> FOR . ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    ID              shift and go to state 104


state 69

    (39) while -> WHILE . LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> WHILE . TRUE LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 105
    TRUE            shift and go to state 106


state 70

    (62) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (73) expression -> . INT
    (74) expression -> . TRUE
    (75) expression -> . FALSE
    (76) expression -> . opera
    (77) expression -> . ID
    (78) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110
    ID              shift and go to state 112
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    expression                     shift and go to state 107
    opera                          shift and go to state 111
    negative                       shift and go to state 113

state 71

    (41) move -> MOVE . LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> MOVE . LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    LPAREN          shift and go to state 114


state 72

    (45) delay -> DELAY . LPAREN INT COMMA STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 115


state 73

    (49) println -> PRINT . EXPR LPAREN args RPAREN SEMICOLON

    EXPR            shift and go to state 116


state 74

    (95) break -> BREAK .

    LOOP            reduce using rule 95 (break -> BREAK .)
    FN              reduce using rule 95 (break -> BREAK .)
    FOR             reduce using rule 95 (break -> BREAK .)
    WHILE           reduce using rule 95 (break -> BREAK .)
    IF              reduce using rule 95 (break -> BREAK .)
    LET             reduce using rule 95 (break -> BREAK .)
    MOVE            reduce using rule 95 (break -> BREAK .)
    DELAY           reduce using rule 95 (break -> BREAK .)
    PRINT           reduce using rule 95 (break -> BREAK .)
    BREAK           reduce using rule 95 (break -> BREAK .)
    ID              reduce using rule 95 (break -> BREAK .)
    RCRLBRACKET     reduce using rule 95 (break -> BREAK .)
    RETURN          reduce using rule 95 (break -> BREAK .)


state 75

    (34) arg -> COMMA params .

    RPAREN          reduce using rule 34 (arg -> COMMA params .)


state 76

    (35) arg -> empty empty .

    RPAREN          reduce using rule 35 (arg -> empty empty .)


state 77

    (9) function -> FN ID LPAREN params RPAREN funbody .

    FN              reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    LET             reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    $end            reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    LOOP            reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    FOR             reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    WHILE           reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    IF              reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    MOVE            reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    DELAY           reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    PRINT           reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    BREAK           reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    ID              reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    RCRLBRACKET     reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)
    RETURN          reduce using rule 9 (function -> FN ID LPAREN params RPAREN funbody .)


state 78

    (7) procedure -> FN ID LPAREN params RPAREN prodbody .

    FN              reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LET             reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    $end            reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LOOP            reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    FOR             reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    WHILE           reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    IF              reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    MOVE            reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    DELAY           reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    PRINT           reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    BREAK           reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    ID              reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RCRLBRACKET     reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RETURN          reduce using rule 7 (procedure -> FN ID LPAREN params RPAREN prodbody .)


state 79

    (10) funbody -> ARROW . output LCRLBRACKET line end RCRLBRACKET
    (11) output -> . INTEGER
    (12) output -> . BOOLEAN

    INTEGER         shift and go to state 118
    BOOLEAN         shift and go to state 119

    output                         shift and go to state 117

state 80

    (8) prodbody -> LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 120
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 81

    (81) opera -> OPERA LPAREN operator . COMMA operand COMMA operand RPAREN

    COMMA           shift and go to state 121


state 82

    (82) operator -> PLUS .

    COMMA           reduce using rule 82 (operator -> PLUS .)


state 83

    (83) operator -> MINUS .

    COMMA           reduce using rule 83 (operator -> MINUS .)


state 84

    (84) operator -> DIVIDE .

    COMMA           reduce using rule 84 (operator -> DIVIDE .)


state 85

    (85) operator -> ASTR .

    COMMA           reduce using rule 85 (operator -> ASTR .)


state 86

    (86) operator -> TIMES .

    COMMA           reduce using rule 86 (operator -> TIMES .)


state 87

    (6) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 6 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 6 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 6 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)


state 88

    (14) line -> loop line .

    RCRLBRACKET     reduce using rule 14 (line -> loop line .)
    RETURN          reduce using rule 14 (line -> loop line .)


state 89

    (15) line -> function line .

    RCRLBRACKET     reduce using rule 15 (line -> function line .)
    RETURN          reduce using rule 15 (line -> function line .)


state 90

    (16) line -> procedure line .

    RCRLBRACKET     reduce using rule 16 (line -> procedure line .)
    RETURN          reduce using rule 16 (line -> procedure line .)


state 91

    (17) line -> for line .

    RCRLBRACKET     reduce using rule 17 (line -> for line .)
    RETURN          reduce using rule 17 (line -> for line .)


state 92

    (18) line -> while line .

    RCRLBRACKET     reduce using rule 18 (line -> while line .)
    RETURN          reduce using rule 18 (line -> while line .)


state 93

    (19) line -> if line .

    RCRLBRACKET     reduce using rule 19 (line -> if line .)
    RETURN          reduce using rule 19 (line -> if line .)


state 94

    (20) line -> let line .

    RCRLBRACKET     reduce using rule 20 (line -> let line .)
    RETURN          reduce using rule 20 (line -> let line .)


state 95

    (21) line -> move line .

    RCRLBRACKET     reduce using rule 21 (line -> move line .)
    RETURN          reduce using rule 21 (line -> move line .)


state 96

    (22) line -> moveList line .

    RCRLBRACKET     reduce using rule 22 (line -> moveList line .)
    RETURN          reduce using rule 22 (line -> moveList line .)


state 97

    (23) line -> delay line .

    RCRLBRACKET     reduce using rule 23 (line -> delay line .)
    RETURN          reduce using rule 23 (line -> delay line .)


state 98

    (24) line -> println line .

    RCRLBRACKET     reduce using rule 24 (line -> println line .)
    RETURN          reduce using rule 24 (line -> println line .)


state 99

    (25) line -> break line .

    RCRLBRACKET     reduce using rule 25 (line -> break line .)
    RETURN          reduce using rule 25 (line -> break line .)


state 100

    (26) line -> declaration line .

    RCRLBRACKET     reduce using rule 26 (line -> declaration line .)
    RETURN          reduce using rule 26 (line -> declaration line .)


state 101

    (27) line -> empty empty .

    RCRLBRACKET     reduce using rule 27 (line -> empty empty .)
    RETURN          reduce using rule 27 (line -> empty empty .)


state 102

    (36) loop -> LOOP LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 122
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 103

    (28) declaration -> ID LPAREN . params RPAREN SEMICOLON
    (29) params -> . ID arg
    (30) params -> . INT arg
    (31) params -> . TRUE arg
    (32) params -> . FALSE arg
    (33) params -> . empty empty
    (96) empty -> .

    ID              shift and go to state 21
    INT             shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    RPAREN          reduce using rule 96 (empty -> .)

    params                         shift and go to state 123
    empty                          shift and go to state 26

state 104

    (37) for -> FOR ID . IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> FOR ID . IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    IN              shift and go to state 124


state 105

    (39) while -> WHILE LPAREN . expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (73) expression -> . INT
    (74) expression -> . TRUE
    (75) expression -> . FALSE
    (76) expression -> . opera
    (77) expression -> . ID
    (78) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110
    ID              shift and go to state 112
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    expression                     shift and go to state 125
    opera                          shift and go to state 111
    negative                       shift and go to state 113

state 106

    (40) while -> WHILE TRUE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 126


state 107

    (62) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (67) compare -> . EQEQ
    (68) compare -> . LTE
    (69) compare -> . GTE
    (70) compare -> . LT
    (71) compare -> . GT
    (72) compare -> . DIF

    EQEQ            shift and go to state 128
    LTE             shift and go to state 129
    GTE             shift and go to state 130
    LT              shift and go to state 131
    GT              shift and go to state 132
    DIF             shift and go to state 133

    compare                        shift and go to state 127

state 108

    (73) expression -> INT .

    EQEQ            reduce using rule 73 (expression -> INT .)
    LTE             reduce using rule 73 (expression -> INT .)
    GTE             reduce using rule 73 (expression -> INT .)
    LT              reduce using rule 73 (expression -> INT .)
    GT              reduce using rule 73 (expression -> INT .)
    DIF             reduce using rule 73 (expression -> INT .)
    LCRLBRACKET     reduce using rule 73 (expression -> INT .)
    RPAREN          reduce using rule 73 (expression -> INT .)
    SEMICOLON       reduce using rule 73 (expression -> INT .)


state 109

    (74) expression -> TRUE .

    EQEQ            reduce using rule 74 (expression -> TRUE .)
    LTE             reduce using rule 74 (expression -> TRUE .)
    GTE             reduce using rule 74 (expression -> TRUE .)
    LT              reduce using rule 74 (expression -> TRUE .)
    GT              reduce using rule 74 (expression -> TRUE .)
    DIF             reduce using rule 74 (expression -> TRUE .)
    LCRLBRACKET     reduce using rule 74 (expression -> TRUE .)
    RPAREN          reduce using rule 74 (expression -> TRUE .)
    SEMICOLON       reduce using rule 74 (expression -> TRUE .)


state 110

    (75) expression -> FALSE .

    EQEQ            reduce using rule 75 (expression -> FALSE .)
    LTE             reduce using rule 75 (expression -> FALSE .)
    GTE             reduce using rule 75 (expression -> FALSE .)
    LT              reduce using rule 75 (expression -> FALSE .)
    GT              reduce using rule 75 (expression -> FALSE .)
    DIF             reduce using rule 75 (expression -> FALSE .)
    LCRLBRACKET     reduce using rule 75 (expression -> FALSE .)
    RPAREN          reduce using rule 75 (expression -> FALSE .)
    SEMICOLON       reduce using rule 75 (expression -> FALSE .)


state 111

    (76) expression -> opera .

    EQEQ            reduce using rule 76 (expression -> opera .)
    LTE             reduce using rule 76 (expression -> opera .)
    GTE             reduce using rule 76 (expression -> opera .)
    LT              reduce using rule 76 (expression -> opera .)
    GT              reduce using rule 76 (expression -> opera .)
    DIF             reduce using rule 76 (expression -> opera .)
    LCRLBRACKET     reduce using rule 76 (expression -> opera .)
    RPAREN          reduce using rule 76 (expression -> opera .)
    SEMICOLON       reduce using rule 76 (expression -> opera .)


state 112

    (77) expression -> ID .

    EQEQ            reduce using rule 77 (expression -> ID .)
    LTE             reduce using rule 77 (expression -> ID .)
    GTE             reduce using rule 77 (expression -> ID .)
    LT              reduce using rule 77 (expression -> ID .)
    GT              reduce using rule 77 (expression -> ID .)
    DIF             reduce using rule 77 (expression -> ID .)
    LCRLBRACKET     reduce using rule 77 (expression -> ID .)
    RPAREN          reduce using rule 77 (expression -> ID .)
    SEMICOLON       reduce using rule 77 (expression -> ID .)


state 113

    (78) expression -> negative .

    EQEQ            reduce using rule 78 (expression -> negative .)
    LTE             reduce using rule 78 (expression -> negative .)
    GTE             reduce using rule 78 (expression -> negative .)
    LT              reduce using rule 78 (expression -> negative .)
    GT              reduce using rule 78 (expression -> negative .)
    DIF             reduce using rule 78 (expression -> negative .)
    LCRLBRACKET     reduce using rule 78 (expression -> negative .)
    RPAREN          reduce using rule 78 (expression -> negative .)
    SEMICOLON       reduce using rule 78 (expression -> negative .)


state 114

    (41) move -> MOVE LPAREN . STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> MOVE LPAREN . LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    STRING          shift and go to state 134
    LSQRBRACKET     shift and go to state 135


state 115

    (45) delay -> DELAY LPAREN . INT COMMA STRING RPAREN SEMICOLON

    INT             shift and go to state 136


state 116

    (49) println -> PRINT EXPR . LPAREN args RPAREN SEMICOLON

    LPAREN          shift and go to state 137


state 117

    (10) funbody -> ARROW output . LCRLBRACKET line end RCRLBRACKET

    LCRLBRACKET     shift and go to state 138


state 118

    (11) output -> INTEGER .

    LCRLBRACKET     reduce using rule 11 (output -> INTEGER .)


state 119

    (12) output -> BOOLEAN .

    LCRLBRACKET     reduce using rule 12 (output -> BOOLEAN .)


state 120

    (8) prodbody -> LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 139


state 121

    (81) opera -> OPERA LPAREN operator COMMA . operand COMMA operand RPAREN
    (87) operand -> . INT
    (88) operand -> . opera
    (89) operand -> . ID
    (90) operand -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 30
    ID              shift and go to state 141
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    operand                        shift and go to state 140
    opera                          shift and go to state 31
    negative                       shift and go to state 32

state 122

    (36) loop -> LOOP LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 142


state 123

    (28) declaration -> ID LPAREN params . RPAREN SEMICOLON

    RPAREN          shift and go to state 143


state 124

    (37) for -> FOR ID IN . INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> FOR ID IN . INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 144


state 125

    (39) while -> WHILE LPAREN expression . compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (67) compare -> . EQEQ
    (68) compare -> . LTE
    (69) compare -> . GTE
    (70) compare -> . LT
    (71) compare -> . GT
    (72) compare -> . DIF

    EQEQ            shift and go to state 128
    LTE             shift and go to state 129
    GTE             shift and go to state 130
    LT              shift and go to state 131
    GT              shift and go to state 132
    DIF             shift and go to state 133

    compare                        shift and go to state 145

state 126

    (40) while -> WHILE TRUE LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 146
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 127

    (62) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (73) expression -> . INT
    (74) expression -> . TRUE
    (75) expression -> . FALSE
    (76) expression -> . opera
    (77) expression -> . ID
    (78) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110
    ID              shift and go to state 112
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    expression                     shift and go to state 147
    opera                          shift and go to state 111
    negative                       shift and go to state 113

state 128

    (67) compare -> EQEQ .

    INT             reduce using rule 67 (compare -> EQEQ .)
    TRUE            reduce using rule 67 (compare -> EQEQ .)
    FALSE           reduce using rule 67 (compare -> EQEQ .)
    ID              reduce using rule 67 (compare -> EQEQ .)
    OPERA           reduce using rule 67 (compare -> EQEQ .)
    MINUS           reduce using rule 67 (compare -> EQEQ .)


state 129

    (68) compare -> LTE .

    INT             reduce using rule 68 (compare -> LTE .)
    TRUE            reduce using rule 68 (compare -> LTE .)
    FALSE           reduce using rule 68 (compare -> LTE .)
    ID              reduce using rule 68 (compare -> LTE .)
    OPERA           reduce using rule 68 (compare -> LTE .)
    MINUS           reduce using rule 68 (compare -> LTE .)


state 130

    (69) compare -> GTE .

    INT             reduce using rule 69 (compare -> GTE .)
    TRUE            reduce using rule 69 (compare -> GTE .)
    FALSE           reduce using rule 69 (compare -> GTE .)
    ID              reduce using rule 69 (compare -> GTE .)
    OPERA           reduce using rule 69 (compare -> GTE .)
    MINUS           reduce using rule 69 (compare -> GTE .)


state 131

    (70) compare -> LT .

    INT             reduce using rule 70 (compare -> LT .)
    TRUE            reduce using rule 70 (compare -> LT .)
    FALSE           reduce using rule 70 (compare -> LT .)
    ID              reduce using rule 70 (compare -> LT .)
    OPERA           reduce using rule 70 (compare -> LT .)
    MINUS           reduce using rule 70 (compare -> LT .)


state 132

    (71) compare -> GT .

    INT             reduce using rule 71 (compare -> GT .)
    TRUE            reduce using rule 71 (compare -> GT .)
    FALSE           reduce using rule 71 (compare -> GT .)
    ID              reduce using rule 71 (compare -> GT .)
    OPERA           reduce using rule 71 (compare -> GT .)
    MINUS           reduce using rule 71 (compare -> GT .)


state 133

    (72) compare -> DIF .

    INT             reduce using rule 72 (compare -> DIF .)
    TRUE            reduce using rule 72 (compare -> DIF .)
    FALSE           reduce using rule 72 (compare -> DIF .)
    ID              reduce using rule 72 (compare -> DIF .)
    OPERA           reduce using rule 72 (compare -> DIF .)
    MINUS           reduce using rule 72 (compare -> DIF .)


state 134

    (41) move -> MOVE LPAREN STRING . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 148


state 135

    (42) moveList -> MOVE LPAREN LSQRBRACKET . fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (43) fingerList -> . STRING COMMA STRING
    (44) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 150

    fingerList                     shift and go to state 149

state 136

    (45) delay -> DELAY LPAREN INT . COMMA STRING RPAREN SEMICOLON

    COMMA           shift and go to state 151


state 137

    (49) println -> PRINT EXPR LPAREN . args RPAREN SEMICOLON
    (50) args -> . INT body
    (51) args -> . ID body
    (52) args -> . opera body
    (53) args -> . TRUE body
    (54) args -> . FALSE body
    (55) args -> . STRING body
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 153
    ID              shift and go to state 154
    TRUE            shift and go to state 156
    FALSE           shift and go to state 157
    STRING          shift and go to state 158
    OPERA           shift and go to state 35

    args                           shift and go to state 152
    opera                          shift and go to state 155

state 138

    (10) funbody -> ARROW output LCRLBRACKET . line end RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RETURN          reduce using rule 96 (empty -> .)

    line                           shift and go to state 159
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 139

    (8) prodbody -> LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 8 (prodbody -> LCRLBRACKET line RCRLBRACKET .)


state 140

    (81) opera -> OPERA LPAREN operator COMMA operand . COMMA operand RPAREN

    COMMA           shift and go to state 160


state 141

    (89) operand -> ID .

    COMMA           reduce using rule 89 (operand -> ID .)
    RPAREN          reduce using rule 89 (operand -> ID .)


state 142

    (36) loop -> LOOP LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 36 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)


state 143

    (28) declaration -> ID LPAREN params RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 161


state 144

    (37) for -> FOR ID IN INT . DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> FOR ID IN INT . DOTDOT INT LCRLBRACKET line RCRLBRACKET

    DOTDOTEQ        shift and go to state 162
    DOTDOT          shift and go to state 163


state 145

    (39) while -> WHILE LPAREN expression compare . expression RPAREN LCRLBRACKET line RCRLBRACKET
    (73) expression -> . INT
    (74) expression -> . TRUE
    (75) expression -> . FALSE
    (76) expression -> . opera
    (77) expression -> . ID
    (78) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110
    ID              shift and go to state 112
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    expression                     shift and go to state 164
    opera                          shift and go to state 111
    negative                       shift and go to state 113

state 146

    (40) while -> WHILE TRUE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 165


state 147

    (62) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (63) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 166


state 148

    (41) move -> MOVE LPAREN STRING COMMA . bool RPAREN SEMICOLON
    (92) bool -> . TRUE
    (93) bool -> . FALSE
    (94) bool -> . ID

    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    ID              shift and go to state 168

    bool                           shift and go to state 167

state 149

    (42) moveList -> MOVE LPAREN LSQRBRACKET fingerList . RSQRBRACKET COMMA bool RPAREN SEMICOLON

    RSQRBRACKET     shift and go to state 169


state 150

    (43) fingerList -> STRING . COMMA STRING
    (44) fingerList -> STRING . COMMA fingerList

    COMMA           shift and go to state 170


state 151

    (45) delay -> DELAY LPAREN INT COMMA . STRING RPAREN SEMICOLON

    STRING          shift and go to state 171


state 152

    (49) println -> PRINT EXPR LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 172


state 153

    (50) args -> INT . body
    (56) body -> . COMMA args
    (57) body -> . COMMA body
    (58) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 174
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 173
    empty                          shift and go to state 175

state 154

    (51) args -> ID . body
    (56) body -> . COMMA args
    (57) body -> . COMMA body
    (58) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 174
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 176
    empty                          shift and go to state 175

state 155

    (52) args -> opera . body
    (56) body -> . COMMA args
    (57) body -> . COMMA body
    (58) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 174
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 177
    empty                          shift and go to state 175

state 156

    (53) args -> TRUE . body
    (56) body -> . COMMA args
    (57) body -> . COMMA body
    (58) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 174
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 178
    empty                          shift and go to state 175

state 157

    (54) args -> FALSE . body
    (56) body -> . COMMA args
    (57) body -> . COMMA body
    (58) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 174
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 179
    empty                          shift and go to state 175

state 158

    (55) args -> STRING . body
    (56) body -> . COMMA args
    (57) body -> . COMMA body
    (58) body -> . empty empty
    (96) empty -> .

    COMMA           shift and go to state 174
    RPAREN          reduce using rule 96 (empty -> .)

    body                           shift and go to state 180
    empty                          shift and go to state 175

state 159

    (10) funbody -> ARROW output LCRLBRACKET line . end RCRLBRACKET
    (13) end -> . RETURN expression SEMICOLON

    RETURN          shift and go to state 182

    end                            shift and go to state 181

state 160

    (81) opera -> OPERA LPAREN operator COMMA operand COMMA . operand RPAREN
    (87) operand -> . INT
    (88) operand -> . opera
    (89) operand -> . ID
    (90) operand -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 30
    ID              shift and go to state 141
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    operand                        shift and go to state 183
    opera                          shift and go to state 31
    negative                       shift and go to state 32

state 161

    (28) declaration -> ID LPAREN params RPAREN SEMICOLON .

    LOOP            reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    FN              reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    FOR             reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    WHILE           reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    IF              reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    LET             reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    MOVE            reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    DELAY           reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    PRINT           reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    BREAK           reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    ID              reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)
    RETURN          reduce using rule 28 (declaration -> ID LPAREN params RPAREN SEMICOLON .)


state 162

    (37) for -> FOR ID IN INT DOTDOTEQ . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 184


state 163

    (38) for -> FOR ID IN INT DOTDOT . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 185


state 164

    (39) while -> WHILE LPAREN expression compare expression . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 186


state 165

    (40) while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 40 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)


state 166

    (62) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (63) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 187
    empty                          shift and go to state 65
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64

state 167

    (41) move -> MOVE LPAREN STRING COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 188


state 168

    (94) bool -> ID .

    RPAREN          reduce using rule 94 (bool -> ID .)


state 169

    (42) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 189


state 170

    (43) fingerList -> STRING COMMA . STRING
    (44) fingerList -> STRING COMMA . fingerList
    (43) fingerList -> . STRING COMMA STRING
    (44) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 190

    fingerList                     shift and go to state 191

state 171

    (45) delay -> DELAY LPAREN INT COMMA STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 192


state 172

    (49) println -> PRINT EXPR LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 193


state 173

    (50) args -> INT body .

    RPAREN          reduce using rule 50 (args -> INT body .)


state 174

    (56) body -> COMMA . args
    (57) body -> COMMA . body
    (50) args -> . INT body
    (51) args -> . ID body
    (52) args -> . opera body
    (53) args -> . TRUE body
    (54) args -> . FALSE body
    (55) args -> . STRING body
    (56) body -> . COMMA args
    (57) body -> . COMMA body
    (58) body -> . empty empty
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (96) empty -> .

    INT             shift and go to state 153
    ID              shift and go to state 154
    TRUE            shift and go to state 156
    FALSE           shift and go to state 157
    STRING          shift and go to state 158
    COMMA           shift and go to state 174
    OPERA           shift and go to state 35
    RPAREN          reduce using rule 96 (empty -> .)

    args                           shift and go to state 194
    body                           shift and go to state 195
    opera                          shift and go to state 155
    empty                          shift and go to state 175

state 175

    (58) body -> empty . empty
    (96) empty -> .

    RPAREN          reduce using rule 96 (empty -> .)

    empty                          shift and go to state 196

state 176

    (51) args -> ID body .

    RPAREN          reduce using rule 51 (args -> ID body .)


state 177

    (52) args -> opera body .

    RPAREN          reduce using rule 52 (args -> opera body .)


state 178

    (53) args -> TRUE body .

    RPAREN          reduce using rule 53 (args -> TRUE body .)


state 179

    (54) args -> FALSE body .

    RPAREN          reduce using rule 54 (args -> FALSE body .)


state 180

    (55) args -> STRING body .

    RPAREN          reduce using rule 55 (args -> STRING body .)


state 181

    (10) funbody -> ARROW output LCRLBRACKET line end . RCRLBRACKET

    RCRLBRACKET     shift and go to state 197


state 182

    (13) end -> RETURN . expression SEMICOLON
    (73) expression -> . INT
    (74) expression -> . TRUE
    (75) expression -> . FALSE
    (76) expression -> . opera
    (77) expression -> . ID
    (78) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110
    ID              shift and go to state 112
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    expression                     shift and go to state 198
    opera                          shift and go to state 111
    negative                       shift and go to state 113

state 183

    (81) opera -> OPERA LPAREN operator COMMA operand COMMA operand . RPAREN

    RPAREN          shift and go to state 199


state 184

    (37) for -> FOR ID IN INT DOTDOTEQ INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 200


state 185

    (38) for -> FOR ID IN INT DOTDOT INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 201


state 186

    (39) while -> WHILE LPAREN expression compare expression RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 202


state 187

    (62) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (63) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 203


state 188

    (41) move -> MOVE LPAREN STRING COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 204


state 189

    (42) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA . bool RPAREN SEMICOLON
    (92) bool -> . TRUE
    (93) bool -> . FALSE
    (94) bool -> . ID

    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    ID              shift and go to state 168

    bool                           shift and go to state 205

state 190

    (43) fingerList -> STRING COMMA STRING .
    (43) fingerList -> STRING . COMMA STRING
    (44) fingerList -> STRING . COMMA fingerList

    RSQRBRACKET     reduce using rule 43 (fingerList -> STRING COMMA STRING .)
    COMMA           shift and go to state 170


state 191

    (44) fingerList -> STRING COMMA fingerList .

    RSQRBRACKET     reduce using rule 44 (fingerList -> STRING COMMA fingerList .)


state 192

    (45) delay -> DELAY LPAREN INT COMMA STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 206


state 193

    (49) println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .

    LOOP            reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FN              reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    LET             reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    MOVE            reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    DELAY           reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    PRINT           reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    BREAK           reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    ID              reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 49 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)


state 194

    (56) body -> COMMA args .

    RPAREN          reduce using rule 56 (body -> COMMA args .)


state 195

    (57) body -> COMMA body .

    RPAREN          reduce using rule 57 (body -> COMMA body .)


state 196

    (58) body -> empty empty .

    RPAREN          reduce using rule 58 (body -> empty empty .)


state 197

    (10) funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .

    FN              reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LET             reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    $end            reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LOOP            reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    FOR             reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    WHILE           reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    IF              reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    MOVE            reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    DELAY           reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    PRINT           reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    BREAK           reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    ID              reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RETURN          reduce using rule 10 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)


state 198

    (13) end -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 207


state 199

    (81) opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .

    SEMICOLON       reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    EQEQ            reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LTE             reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GTE             reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LT              reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GT              reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    DIF             reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    COMMA           reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LCRLBRACKET     reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    RPAREN          reduce using rule 81 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)


state 200

    (37) for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 208
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 201

    (38) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 209
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 202

    (39) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 210
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 203

    (62) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (63) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (96) empty -> .
    (60) elseiforelse -> . elseif
    (61) elseiforelse -> . else
    (64) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (65) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (66) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 96 (empty -> .)
    FN              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    WHILE           reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    LET             reduce using rule 96 (empty -> .)
    MOVE            reduce using rule 96 (empty -> .)
    DELAY           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)
    ELSEIF          shift and go to state 215
    ELSE            shift and go to state 216

    empty                          shift and go to state 211
    elseiforelse                   shift and go to state 212
    elseif                         shift and go to state 213
    else                           shift and go to state 214

state 204

    (41) move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    ID              reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 41 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)


state 205

    (42) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 217


state 206

    (45) delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .

    LOOP            reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FN              reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    IF              reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    LET             reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    MOVE            reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    DELAY           reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    PRINT           reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    BREAK           reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    ID              reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 45 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)


state 207

    (13) end -> RETURN expression SEMICOLON .

    RCRLBRACKET     reduce using rule 13 (end -> RETURN expression SEMICOLON .)


state 208

    (37) for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 218


state 209

    (38) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 219


state 210

    (39) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 220


state 211

    (62) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    ID              reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 62 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 212

    (63) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    ID              reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 63 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)


state 213

    (60) elseiforelse -> elseif .

    LOOP            reduce using rule 60 (elseiforelse -> elseif .)
    FN              reduce using rule 60 (elseiforelse -> elseif .)
    FOR             reduce using rule 60 (elseiforelse -> elseif .)
    WHILE           reduce using rule 60 (elseiforelse -> elseif .)
    IF              reduce using rule 60 (elseiforelse -> elseif .)
    LET             reduce using rule 60 (elseiforelse -> elseif .)
    MOVE            reduce using rule 60 (elseiforelse -> elseif .)
    DELAY           reduce using rule 60 (elseiforelse -> elseif .)
    PRINT           reduce using rule 60 (elseiforelse -> elseif .)
    BREAK           reduce using rule 60 (elseiforelse -> elseif .)
    ID              reduce using rule 60 (elseiforelse -> elseif .)
    RCRLBRACKET     reduce using rule 60 (elseiforelse -> elseif .)
    RETURN          reduce using rule 60 (elseiforelse -> elseif .)


state 214

    (61) elseiforelse -> else .

    LOOP            reduce using rule 61 (elseiforelse -> else .)
    FN              reduce using rule 61 (elseiforelse -> else .)
    FOR             reduce using rule 61 (elseiforelse -> else .)
    WHILE           reduce using rule 61 (elseiforelse -> else .)
    IF              reduce using rule 61 (elseiforelse -> else .)
    LET             reduce using rule 61 (elseiforelse -> else .)
    MOVE            reduce using rule 61 (elseiforelse -> else .)
    DELAY           reduce using rule 61 (elseiforelse -> else .)
    PRINT           reduce using rule 61 (elseiforelse -> else .)
    BREAK           reduce using rule 61 (elseiforelse -> else .)
    ID              reduce using rule 61 (elseiforelse -> else .)
    RCRLBRACKET     reduce using rule 61 (elseiforelse -> else .)
    RETURN          reduce using rule 61 (elseiforelse -> else .)


state 215

    (64) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (65) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (73) expression -> . INT
    (74) expression -> . TRUE
    (75) expression -> . FALSE
    (76) expression -> . opera
    (77) expression -> . ID
    (78) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110
    ID              shift and go to state 112
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    expression                     shift and go to state 221
    opera                          shift and go to state 111
    negative                       shift and go to state 113

state 216

    (66) else -> ELSE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 222


state 217

    (42) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 223


state 218

    (37) for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 37 (for -> FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET .)


state 219

    (38) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 38 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)


state 220

    (39) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 39 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)


state 221

    (64) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (65) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (67) compare -> . EQEQ
    (68) compare -> . LTE
    (69) compare -> . GTE
    (70) compare -> . LT
    (71) compare -> . GT
    (72) compare -> . DIF

    EQEQ            shift and go to state 128
    LTE             shift and go to state 129
    GTE             shift and go to state 130
    LT              shift and go to state 131
    GT              shift and go to state 132
    DIF             shift and go to state 133

    compare                        shift and go to state 224

state 222

    (66) else -> ELSE LCRLBRACKET . line RCRLBRACKET
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 225
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64
    empty                          shift and go to state 65

state 223

    (42) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    ID              reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 42 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)


state 224

    (64) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (65) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (73) expression -> . INT
    (74) expression -> . TRUE
    (75) expression -> . FALSE
    (76) expression -> . opera
    (77) expression -> . ID
    (78) expression -> . negative
    (81) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) negative -> . MINUS INT

    INT             shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110
    ID              shift and go to state 112
    OPERA           shift and go to state 35
    MINUS           shift and go to state 36

    expression                     shift and go to state 226
    opera                          shift and go to state 111
    negative                       shift and go to state 113

state 225

    (66) else -> ELSE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 227


state 226

    (64) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (65) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 228


state 227

    (66) else -> ELSE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    ID              reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 66 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)


state 228

    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (65) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (14) line -> . loop line
    (15) line -> . function line
    (16) line -> . procedure line
    (17) line -> . for line
    (18) line -> . while line
    (19) line -> . if line
    (20) line -> . let line
    (21) line -> . move line
    (22) line -> . moveList line
    (23) line -> . delay line
    (24) line -> . println line
    (25) line -> . break line
    (26) line -> . declaration line
    (27) line -> . empty empty
    (36) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (9) function -> . FN ID LPAREN params RPAREN funbody
    (7) procedure -> . FN ID LPAREN params RPAREN prodbody
    (37) for -> . FOR ID IN INT DOTDOTEQ INT LCRLBRACKET line RCRLBRACKET
    (38) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (39) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (40) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (62) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (63) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (79) let -> . LET ID ASSIGN operand SEMICOLON
    (80) let -> . LET ID ASSIGN bool SEMICOLON
    (41) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (42) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (45) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (49) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (95) break -> . BREAK
    (28) declaration -> . ID LPAREN params RPAREN SEMICOLON
    (96) empty -> .

    LOOP            shift and go to state 66
    FN              shift and go to state 50
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    LET             shift and go to state 8
    MOVE            shift and go to state 71
    DELAY           shift and go to state 72
    PRINT           shift and go to state 73
    BREAK           shift and go to state 74
    ID              shift and go to state 67
    RCRLBRACKET     reduce using rule 96 (empty -> .)

    line                           shift and go to state 229
    empty                          shift and go to state 65
    loop                           shift and go to state 52
    function                       shift and go to state 53
    procedure                      shift and go to state 54
    for                            shift and go to state 55
    while                          shift and go to state 56
    if                             shift and go to state 57
    let                            shift and go to state 58
    move                           shift and go to state 59
    moveList                       shift and go to state 60
    delay                          shift and go to state 61
    println                        shift and go to state 62
    break                          shift and go to state 63
    declaration                    shift and go to state 64

state 229

    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (65) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 230


state 230

    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (65) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (96) empty -> .
    (60) elseiforelse -> . elseif
    (61) elseiforelse -> . else
    (64) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (65) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (66) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 96 (empty -> .)
    FN              reduce using rule 96 (empty -> .)
    FOR             reduce using rule 96 (empty -> .)
    WHILE           reduce using rule 96 (empty -> .)
    IF              reduce using rule 96 (empty -> .)
    LET             reduce using rule 96 (empty -> .)
    MOVE            reduce using rule 96 (empty -> .)
    DELAY           reduce using rule 96 (empty -> .)
    PRINT           reduce using rule 96 (empty -> .)
    BREAK           reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    RCRLBRACKET     reduce using rule 96 (empty -> .)
    RETURN          reduce using rule 96 (empty -> .)
    ELSEIF          shift and go to state 215
    ELSE            shift and go to state 216

    empty                          shift and go to state 231
    elseiforelse                   shift and go to state 232
    elseif                         shift and go to state 213
    else                           shift and go to state 214

state 231

    (64) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    ID              reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 64 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 232

    (65) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    ID              reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 65 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 27 resolved using rule (operand -> ID)
WARNING: rejected rule (bool -> ID) in state 27
