Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    INTEGER
    RANGE
    RETURN
    WRONG_ID

Grammar

Rule 0     S' -> line
Rule 1     line -> main line
Rule 2     line -> loop line
Rule 3     line -> for line
Rule 4     line -> while line
Rule 5     line -> if line
Rule 6     line -> let line
Rule 7     line -> move line
Rule 8     line -> moveList line
Rule 9     line -> delay line
Rule 10    line -> println line
Rule 11    line -> break line
Rule 12    line -> empty
Rule 13    main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
Rule 14    loop -> LOOP LCRLBRACKET line RCRLBRACKET
Rule 15    for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
Rule 16    while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
Rule 17    while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET
Rule 18    move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
Rule 19    moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
Rule 20    fingerList -> STRING COMMA STRING
Rule 21    fingerList -> STRING COMMA fingerList
Rule 22    delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
Rule 23    unit -> QUOT MIN QUOT
Rule 24    unit -> QUOT MIL QUOT
Rule 25    unit -> QUOT SEG QUOT
Rule 26    println -> PRINT EXPR LPAREN args RPAREN SEMICOLON
Rule 27    args -> INT body
Rule 28    args -> ID body
Rule 29    args -> opera body
Rule 30    args -> TRUE body
Rule 31    args -> FALSE body
Rule 32    args -> STRING body
Rule 33    body -> COMMA args
Rule 34    body -> COMMA body
Rule 35    body -> empty empty
Rule 36    text -> QUOT ID QUOT
Rule 37    elseiforelse -> elseif
Rule 38    elseiforelse -> else
Rule 39    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET
Rule 40    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 41    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line
Rule 42    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 43    else -> ELSE LCRLBRACKET line RCRLBRACKET line
Rule 44    compare -> EQEQ
Rule 45    compare -> LTE
Rule 46    compare -> GTE
Rule 47    compare -> LT
Rule 48    compare -> GT
Rule 49    expression -> INT
Rule 50    expression -> TRUE
Rule 51    expression -> FALSE
Rule 52    expression -> opera
Rule 53    expression -> ID
Rule 54    let -> LET ID ASSIGN operand SEMICOLON
Rule 55    let -> LET ID ASSIGN bool SEMICOLON
Rule 56    opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN
Rule 57    operator -> PLUS
Rule 58    operator -> MINUS
Rule 59    operator -> DIVIDE
Rule 60    operator -> ASTR
Rule 61    operator -> TIMES
Rule 62    operand -> INT
Rule 63    operand -> opera
Rule 64    operand -> ID
Rule 65    bool -> TRUE
Rule 66    bool -> FALSE
Rule 67    bool -> ID
Rule 68    break -> BREAK
Rule 69    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 
ASSIGN               : 54 55
ASTR                 : 60
BREAK                : 68
COMMA                : 18 19 20 21 22 33 34 56 56
DELAY                : 22
DIVIDE               : 59
DOTDOT               : 15
ELSE                 : 43
ELSEIF               : 41 42
EQEQ                 : 44
EXPR                 : 26
FALSE                : 31 51 66
FN                   : 13
FOR                  : 15
GT                   : 48
GTE                  : 46
ID                   : 15 28 36 53 54 55 64 67
IF                   : 39 40
IN                   : 15
INT                  : 15 15 22 27 49 62
INTEGER              : 
LCRLBRACKET          : 13 14 15 16 17 39 40 41 42 43
LET                  : 54 55
LOOP                 : 14
LPAREN               : 13 16 18 19 22 26 56
LSQRBRACKET          : 19
LT                   : 47
LTE                  : 45
MAIN                 : 13
MIL                  : 24
MIN                  : 23
MINUS                : 58
MOVE                 : 18 19
OPERA                : 56
PLUS                 : 57
PRINT                : 26
QUOT                 : 23 23 24 24 25 25 36 36
RANGE                : 
RCRLBRACKET          : 13 14 15 16 17 39 40 41 42 43
RETURN               : 
RPAREN               : 13 16 18 19 22 26 56
RSQRBRACKET          : 19
SEG                  : 25
SEMICOLON            : 18 19 22 26 54 55
STRING               : 18 20 20 21 22 32
TIMES                : 61
TRUE                 : 17 30 50 65
WHILE                : 16 17
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

args                 : 26 33
body                 : 27 28 29 30 31 32 34
bool                 : 18 19 55
break                : 11
compare              : 16 39 40 41 42
delay                : 9
else                 : 38
elseif               : 37
elseiforelse         : 40 42
empty                : 12 35 35
expression           : 16 16 39 39 40 40 41 41 42 42
fingerList           : 19 21
for                  : 3
if                   : 5
let                  : 6
line                 : 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16 17 39 40 41 41 42 43 43 0
loop                 : 2
main                 : 1
move                 : 7
moveList             : 8
opera                : 29 52 63
operand              : 54 56 56
operator             : 56
println              : 10
text                 : 
unit                 : 
while                : 4

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)

    line                           shift and go to state 1
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 1

    (0) S' -> line .



state 2

    (1) line -> main . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    main                           shift and go to state 2
    line                           shift and go to state 24
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 3

    (2) line -> loop . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    loop                           shift and go to state 3
    line                           shift and go to state 25
    main                           shift and go to state 2
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 4

    (3) line -> for . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    for                            shift and go to state 4
    line                           shift and go to state 26
    main                           shift and go to state 2
    loop                           shift and go to state 3
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 5

    (4) line -> while . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    while                          shift and go to state 5
    line                           shift and go to state 27
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 6

    (5) line -> if . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    if                             shift and go to state 6
    line                           shift and go to state 28
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 7

    (6) line -> let . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    let                            shift and go to state 7
    line                           shift and go to state 29
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 8

    (7) line -> move . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    move                           shift and go to state 8
    line                           shift and go to state 30
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 9

    (8) line -> moveList . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    moveList                       shift and go to state 9
    line                           shift and go to state 31
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 10

    (9) line -> delay . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    delay                          shift and go to state 10
    line                           shift and go to state 32
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 11

    (10) line -> println . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    println                        shift and go to state 11
    line                           shift and go to state 33
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 12

    (11) line -> break . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    break                          shift and go to state 12
    line                           shift and go to state 34
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    empty                          shift and go to state 13

state 13

    (12) line -> empty .

    $end            reduce using rule 12 (line -> empty .)
    RCRLBRACKET     reduce using rule 12 (line -> empty .)
    FN              reduce using rule 12 (line -> empty .)
    LOOP            reduce using rule 12 (line -> empty .)
    FOR             reduce using rule 12 (line -> empty .)
    WHILE           reduce using rule 12 (line -> empty .)
    IF              reduce using rule 12 (line -> empty .)
    LET             reduce using rule 12 (line -> empty .)
    MOVE            reduce using rule 12 (line -> empty .)
    DELAY           reduce using rule 12 (line -> empty .)
    PRINT           reduce using rule 12 (line -> empty .)
    BREAK           reduce using rule 12 (line -> empty .)


state 14

    (13) main -> FN . MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET

    MAIN            shift and go to state 35


state 15

    (14) loop -> LOOP . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 36


state 16

    (15) for -> FOR . ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    ID              shift and go to state 37


state 17

    (16) while -> WHILE . LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> WHILE . TRUE LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 38
    TRUE            shift and go to state 39


state 18

    (39) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (49) expression -> . INT
    (50) expression -> . TRUE
    (51) expression -> . FALSE
    (52) expression -> . opera
    (53) expression -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 45
    OPERA           shift and go to state 46

    expression                     shift and go to state 40
    opera                          shift and go to state 44

state 19

    (54) let -> LET . ID ASSIGN operand SEMICOLON
    (55) let -> LET . ID ASSIGN bool SEMICOLON

    ID              shift and go to state 47


state 20

    (18) move -> MOVE . LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> MOVE . LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    LPAREN          shift and go to state 48


state 21

    (22) delay -> DELAY . LPAREN INT COMMA STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 49


state 22

    (26) println -> PRINT . EXPR LPAREN args RPAREN SEMICOLON

    EXPR            shift and go to state 50


state 23

    (68) break -> BREAK .

    FN              reduce using rule 68 (break -> BREAK .)
    LOOP            reduce using rule 68 (break -> BREAK .)
    FOR             reduce using rule 68 (break -> BREAK .)
    WHILE           reduce using rule 68 (break -> BREAK .)
    IF              reduce using rule 68 (break -> BREAK .)
    LET             reduce using rule 68 (break -> BREAK .)
    MOVE            reduce using rule 68 (break -> BREAK .)
    DELAY           reduce using rule 68 (break -> BREAK .)
    PRINT           reduce using rule 68 (break -> BREAK .)
    BREAK           reduce using rule 68 (break -> BREAK .)
    $end            reduce using rule 68 (break -> BREAK .)
    RCRLBRACKET     reduce using rule 68 (break -> BREAK .)


state 24

    (1) line -> main line .

    $end            reduce using rule 1 (line -> main line .)
    RCRLBRACKET     reduce using rule 1 (line -> main line .)
    FN              reduce using rule 1 (line -> main line .)
    LOOP            reduce using rule 1 (line -> main line .)
    FOR             reduce using rule 1 (line -> main line .)
    WHILE           reduce using rule 1 (line -> main line .)
    IF              reduce using rule 1 (line -> main line .)
    LET             reduce using rule 1 (line -> main line .)
    MOVE            reduce using rule 1 (line -> main line .)
    DELAY           reduce using rule 1 (line -> main line .)
    PRINT           reduce using rule 1 (line -> main line .)
    BREAK           reduce using rule 1 (line -> main line .)


state 25

    (2) line -> loop line .

    $end            reduce using rule 2 (line -> loop line .)
    RCRLBRACKET     reduce using rule 2 (line -> loop line .)
    FN              reduce using rule 2 (line -> loop line .)
    LOOP            reduce using rule 2 (line -> loop line .)
    FOR             reduce using rule 2 (line -> loop line .)
    WHILE           reduce using rule 2 (line -> loop line .)
    IF              reduce using rule 2 (line -> loop line .)
    LET             reduce using rule 2 (line -> loop line .)
    MOVE            reduce using rule 2 (line -> loop line .)
    DELAY           reduce using rule 2 (line -> loop line .)
    PRINT           reduce using rule 2 (line -> loop line .)
    BREAK           reduce using rule 2 (line -> loop line .)


state 26

    (3) line -> for line .

    $end            reduce using rule 3 (line -> for line .)
    RCRLBRACKET     reduce using rule 3 (line -> for line .)
    FN              reduce using rule 3 (line -> for line .)
    LOOP            reduce using rule 3 (line -> for line .)
    FOR             reduce using rule 3 (line -> for line .)
    WHILE           reduce using rule 3 (line -> for line .)
    IF              reduce using rule 3 (line -> for line .)
    LET             reduce using rule 3 (line -> for line .)
    MOVE            reduce using rule 3 (line -> for line .)
    DELAY           reduce using rule 3 (line -> for line .)
    PRINT           reduce using rule 3 (line -> for line .)
    BREAK           reduce using rule 3 (line -> for line .)


state 27

    (4) line -> while line .

    $end            reduce using rule 4 (line -> while line .)
    RCRLBRACKET     reduce using rule 4 (line -> while line .)
    FN              reduce using rule 4 (line -> while line .)
    LOOP            reduce using rule 4 (line -> while line .)
    FOR             reduce using rule 4 (line -> while line .)
    WHILE           reduce using rule 4 (line -> while line .)
    IF              reduce using rule 4 (line -> while line .)
    LET             reduce using rule 4 (line -> while line .)
    MOVE            reduce using rule 4 (line -> while line .)
    DELAY           reduce using rule 4 (line -> while line .)
    PRINT           reduce using rule 4 (line -> while line .)
    BREAK           reduce using rule 4 (line -> while line .)


state 28

    (5) line -> if line .

    $end            reduce using rule 5 (line -> if line .)
    RCRLBRACKET     reduce using rule 5 (line -> if line .)
    FN              reduce using rule 5 (line -> if line .)
    LOOP            reduce using rule 5 (line -> if line .)
    FOR             reduce using rule 5 (line -> if line .)
    WHILE           reduce using rule 5 (line -> if line .)
    IF              reduce using rule 5 (line -> if line .)
    LET             reduce using rule 5 (line -> if line .)
    MOVE            reduce using rule 5 (line -> if line .)
    DELAY           reduce using rule 5 (line -> if line .)
    PRINT           reduce using rule 5 (line -> if line .)
    BREAK           reduce using rule 5 (line -> if line .)


state 29

    (6) line -> let line .

    $end            reduce using rule 6 (line -> let line .)
    RCRLBRACKET     reduce using rule 6 (line -> let line .)
    FN              reduce using rule 6 (line -> let line .)
    LOOP            reduce using rule 6 (line -> let line .)
    FOR             reduce using rule 6 (line -> let line .)
    WHILE           reduce using rule 6 (line -> let line .)
    IF              reduce using rule 6 (line -> let line .)
    LET             reduce using rule 6 (line -> let line .)
    MOVE            reduce using rule 6 (line -> let line .)
    DELAY           reduce using rule 6 (line -> let line .)
    PRINT           reduce using rule 6 (line -> let line .)
    BREAK           reduce using rule 6 (line -> let line .)


state 30

    (7) line -> move line .

    $end            reduce using rule 7 (line -> move line .)
    RCRLBRACKET     reduce using rule 7 (line -> move line .)
    FN              reduce using rule 7 (line -> move line .)
    LOOP            reduce using rule 7 (line -> move line .)
    FOR             reduce using rule 7 (line -> move line .)
    WHILE           reduce using rule 7 (line -> move line .)
    IF              reduce using rule 7 (line -> move line .)
    LET             reduce using rule 7 (line -> move line .)
    MOVE            reduce using rule 7 (line -> move line .)
    DELAY           reduce using rule 7 (line -> move line .)
    PRINT           reduce using rule 7 (line -> move line .)
    BREAK           reduce using rule 7 (line -> move line .)


state 31

    (8) line -> moveList line .

    $end            reduce using rule 8 (line -> moveList line .)
    RCRLBRACKET     reduce using rule 8 (line -> moveList line .)
    FN              reduce using rule 8 (line -> moveList line .)
    LOOP            reduce using rule 8 (line -> moveList line .)
    FOR             reduce using rule 8 (line -> moveList line .)
    WHILE           reduce using rule 8 (line -> moveList line .)
    IF              reduce using rule 8 (line -> moveList line .)
    LET             reduce using rule 8 (line -> moveList line .)
    MOVE            reduce using rule 8 (line -> moveList line .)
    DELAY           reduce using rule 8 (line -> moveList line .)
    PRINT           reduce using rule 8 (line -> moveList line .)
    BREAK           reduce using rule 8 (line -> moveList line .)


state 32

    (9) line -> delay line .

    $end            reduce using rule 9 (line -> delay line .)
    RCRLBRACKET     reduce using rule 9 (line -> delay line .)
    FN              reduce using rule 9 (line -> delay line .)
    LOOP            reduce using rule 9 (line -> delay line .)
    FOR             reduce using rule 9 (line -> delay line .)
    WHILE           reduce using rule 9 (line -> delay line .)
    IF              reduce using rule 9 (line -> delay line .)
    LET             reduce using rule 9 (line -> delay line .)
    MOVE            reduce using rule 9 (line -> delay line .)
    DELAY           reduce using rule 9 (line -> delay line .)
    PRINT           reduce using rule 9 (line -> delay line .)
    BREAK           reduce using rule 9 (line -> delay line .)


state 33

    (10) line -> println line .

    $end            reduce using rule 10 (line -> println line .)
    RCRLBRACKET     reduce using rule 10 (line -> println line .)
    FN              reduce using rule 10 (line -> println line .)
    LOOP            reduce using rule 10 (line -> println line .)
    FOR             reduce using rule 10 (line -> println line .)
    WHILE           reduce using rule 10 (line -> println line .)
    IF              reduce using rule 10 (line -> println line .)
    LET             reduce using rule 10 (line -> println line .)
    MOVE            reduce using rule 10 (line -> println line .)
    DELAY           reduce using rule 10 (line -> println line .)
    PRINT           reduce using rule 10 (line -> println line .)
    BREAK           reduce using rule 10 (line -> println line .)


state 34

    (11) line -> break line .

    $end            reduce using rule 11 (line -> break line .)
    RCRLBRACKET     reduce using rule 11 (line -> break line .)
    FN              reduce using rule 11 (line -> break line .)
    LOOP            reduce using rule 11 (line -> break line .)
    FOR             reduce using rule 11 (line -> break line .)
    WHILE           reduce using rule 11 (line -> break line .)
    IF              reduce using rule 11 (line -> break line .)
    LET             reduce using rule 11 (line -> break line .)
    MOVE            reduce using rule 11 (line -> break line .)
    DELAY           reduce using rule 11 (line -> break line .)
    PRINT           reduce using rule 11 (line -> break line .)
    BREAK           reduce using rule 11 (line -> break line .)


state 35

    (13) main -> FN MAIN . LPAREN RPAREN LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 51


state 36

    (14) loop -> LOOP LCRLBRACKET . line RCRLBRACKET
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 52
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 37

    (15) for -> FOR ID . IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    IN              shift and go to state 53


state 38

    (16) while -> WHILE LPAREN . expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (49) expression -> . INT
    (50) expression -> . TRUE
    (51) expression -> . FALSE
    (52) expression -> . opera
    (53) expression -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 45
    OPERA           shift and go to state 46

    expression                     shift and go to state 54
    opera                          shift and go to state 44

state 39

    (17) while -> WHILE TRUE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 55


state 40

    (39) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (44) compare -> . EQEQ
    (45) compare -> . LTE
    (46) compare -> . GTE
    (47) compare -> . LT
    (48) compare -> . GT

    EQEQ            shift and go to state 57
    LTE             shift and go to state 58
    GTE             shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61

    compare                        shift and go to state 56

state 41

    (49) expression -> INT .

    EQEQ            reduce using rule 49 (expression -> INT .)
    LTE             reduce using rule 49 (expression -> INT .)
    GTE             reduce using rule 49 (expression -> INT .)
    LT              reduce using rule 49 (expression -> INT .)
    GT              reduce using rule 49 (expression -> INT .)
    LCRLBRACKET     reduce using rule 49 (expression -> INT .)
    RPAREN          reduce using rule 49 (expression -> INT .)


state 42

    (50) expression -> TRUE .

    EQEQ            reduce using rule 50 (expression -> TRUE .)
    LTE             reduce using rule 50 (expression -> TRUE .)
    GTE             reduce using rule 50 (expression -> TRUE .)
    LT              reduce using rule 50 (expression -> TRUE .)
    GT              reduce using rule 50 (expression -> TRUE .)
    LCRLBRACKET     reduce using rule 50 (expression -> TRUE .)
    RPAREN          reduce using rule 50 (expression -> TRUE .)


state 43

    (51) expression -> FALSE .

    EQEQ            reduce using rule 51 (expression -> FALSE .)
    LTE             reduce using rule 51 (expression -> FALSE .)
    GTE             reduce using rule 51 (expression -> FALSE .)
    LT              reduce using rule 51 (expression -> FALSE .)
    GT              reduce using rule 51 (expression -> FALSE .)
    LCRLBRACKET     reduce using rule 51 (expression -> FALSE .)
    RPAREN          reduce using rule 51 (expression -> FALSE .)


state 44

    (52) expression -> opera .

    EQEQ            reduce using rule 52 (expression -> opera .)
    LTE             reduce using rule 52 (expression -> opera .)
    GTE             reduce using rule 52 (expression -> opera .)
    LT              reduce using rule 52 (expression -> opera .)
    GT              reduce using rule 52 (expression -> opera .)
    LCRLBRACKET     reduce using rule 52 (expression -> opera .)
    RPAREN          reduce using rule 52 (expression -> opera .)


state 45

    (53) expression -> ID .

    EQEQ            reduce using rule 53 (expression -> ID .)
    LTE             reduce using rule 53 (expression -> ID .)
    GTE             reduce using rule 53 (expression -> ID .)
    LT              reduce using rule 53 (expression -> ID .)
    GT              reduce using rule 53 (expression -> ID .)
    LCRLBRACKET     reduce using rule 53 (expression -> ID .)
    RPAREN          reduce using rule 53 (expression -> ID .)


state 46

    (56) opera -> OPERA . LPAREN operator COMMA operand COMMA operand RPAREN

    LPAREN          shift and go to state 62


state 47

    (54) let -> LET ID . ASSIGN operand SEMICOLON
    (55) let -> LET ID . ASSIGN bool SEMICOLON

    ASSIGN          shift and go to state 63


state 48

    (18) move -> MOVE LPAREN . STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> MOVE LPAREN . LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    STRING          shift and go to state 64
    LSQRBRACKET     shift and go to state 65


state 49

    (22) delay -> DELAY LPAREN . INT COMMA STRING RPAREN SEMICOLON

    INT             shift and go to state 66


state 50

    (26) println -> PRINT EXPR . LPAREN args RPAREN SEMICOLON

    LPAREN          shift and go to state 67


state 51

    (13) main -> FN MAIN LPAREN . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 68


state 52

    (14) loop -> LOOP LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 69


state 53

    (15) for -> FOR ID IN . INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 70


state 54

    (16) while -> WHILE LPAREN expression . compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (44) compare -> . EQEQ
    (45) compare -> . LTE
    (46) compare -> . GTE
    (47) compare -> . LT
    (48) compare -> . GT

    EQEQ            shift and go to state 57
    LTE             shift and go to state 58
    GTE             shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61

    compare                        shift and go to state 71

state 55

    (17) while -> WHILE TRUE LCRLBRACKET . line RCRLBRACKET
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 72
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 56

    (39) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET
    (40) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (49) expression -> . INT
    (50) expression -> . TRUE
    (51) expression -> . FALSE
    (52) expression -> . opera
    (53) expression -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 45
    OPERA           shift and go to state 46

    expression                     shift and go to state 73
    opera                          shift and go to state 44

state 57

    (44) compare -> EQEQ .

    INT             reduce using rule 44 (compare -> EQEQ .)
    TRUE            reduce using rule 44 (compare -> EQEQ .)
    FALSE           reduce using rule 44 (compare -> EQEQ .)
    ID              reduce using rule 44 (compare -> EQEQ .)
    OPERA           reduce using rule 44 (compare -> EQEQ .)


state 58

    (45) compare -> LTE .

    INT             reduce using rule 45 (compare -> LTE .)
    TRUE            reduce using rule 45 (compare -> LTE .)
    FALSE           reduce using rule 45 (compare -> LTE .)
    ID              reduce using rule 45 (compare -> LTE .)
    OPERA           reduce using rule 45 (compare -> LTE .)


state 59

    (46) compare -> GTE .

    INT             reduce using rule 46 (compare -> GTE .)
    TRUE            reduce using rule 46 (compare -> GTE .)
    FALSE           reduce using rule 46 (compare -> GTE .)
    ID              reduce using rule 46 (compare -> GTE .)
    OPERA           reduce using rule 46 (compare -> GTE .)


state 60

    (47) compare -> LT .

    INT             reduce using rule 47 (compare -> LT .)
    TRUE            reduce using rule 47 (compare -> LT .)
    FALSE           reduce using rule 47 (compare -> LT .)
    ID              reduce using rule 47 (compare -> LT .)
    OPERA           reduce using rule 47 (compare -> LT .)


state 61

    (48) compare -> GT .

    INT             reduce using rule 48 (compare -> GT .)
    TRUE            reduce using rule 48 (compare -> GT .)
    FALSE           reduce using rule 48 (compare -> GT .)
    ID              reduce using rule 48 (compare -> GT .)
    OPERA           reduce using rule 48 (compare -> GT .)


state 62

    (56) opera -> OPERA LPAREN . operator COMMA operand COMMA operand RPAREN
    (57) operator -> . PLUS
    (58) operator -> . MINUS
    (59) operator -> . DIVIDE
    (60) operator -> . ASTR
    (61) operator -> . TIMES

    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    DIVIDE          shift and go to state 77
    ASTR            shift and go to state 78
    TIMES           shift and go to state 79

    operator                       shift and go to state 74

state 63

    (54) let -> LET ID ASSIGN . operand SEMICOLON
    (55) let -> LET ID ASSIGN . bool SEMICOLON
    (62) operand -> . INT
    (63) operand -> . opera
    (64) operand -> . ID
    (65) bool -> . TRUE
    (66) bool -> . FALSE
    (67) bool -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 83
    ID              shift and go to state 80
    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    OPERA           shift and go to state 46

    operand                        shift and go to state 81
    bool                           shift and go to state 82
    opera                          shift and go to state 84

state 64

    (18) move -> MOVE LPAREN STRING . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 87


state 65

    (19) moveList -> MOVE LPAREN LSQRBRACKET . fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (20) fingerList -> . STRING COMMA STRING
    (21) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 89

    fingerList                     shift and go to state 88

state 66

    (22) delay -> DELAY LPAREN INT . COMMA STRING RPAREN SEMICOLON

    COMMA           shift and go to state 90


state 67

    (26) println -> PRINT EXPR LPAREN . args RPAREN SEMICOLON
    (27) args -> . INT body
    (28) args -> . ID body
    (29) args -> . opera body
    (30) args -> . TRUE body
    (31) args -> . FALSE body
    (32) args -> . STRING body
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 92
    ID              shift and go to state 93
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    STRING          shift and go to state 97
    OPERA           shift and go to state 46

    args                           shift and go to state 91
    opera                          shift and go to state 94

state 68

    (13) main -> FN MAIN LPAREN RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 98


state 69

    (14) loop -> LOOP LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 14 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)


state 70

    (15) for -> FOR ID IN INT . DOTDOT INT LCRLBRACKET line RCRLBRACKET

    DOTDOT          shift and go to state 99


state 71

    (16) while -> WHILE LPAREN expression compare . expression RPAREN LCRLBRACKET line RCRLBRACKET
    (49) expression -> . INT
    (50) expression -> . TRUE
    (51) expression -> . FALSE
    (52) expression -> . opera
    (53) expression -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 45
    OPERA           shift and go to state 46

    expression                     shift and go to state 100
    opera                          shift and go to state 44

state 72

    (17) while -> WHILE TRUE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 101


state 73

    (39) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET
    (40) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 102


state 74

    (56) opera -> OPERA LPAREN operator . COMMA operand COMMA operand RPAREN

    COMMA           shift and go to state 103


state 75

    (57) operator -> PLUS .

    COMMA           reduce using rule 57 (operator -> PLUS .)


state 76

    (58) operator -> MINUS .

    COMMA           reduce using rule 58 (operator -> MINUS .)


state 77

    (59) operator -> DIVIDE .

    COMMA           reduce using rule 59 (operator -> DIVIDE .)


state 78

    (60) operator -> ASTR .

    COMMA           reduce using rule 60 (operator -> ASTR .)


state 79

    (61) operator -> TIMES .

    COMMA           reduce using rule 61 (operator -> TIMES .)


state 80

    (64) operand -> ID .
    (67) bool -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 64 (operand -> ID .)
    SEMICOLON       reduce using rule 64 (operand -> ID .)

  ! SEMICOLON       [ reduce using rule 67 (bool -> ID .) ]


state 81

    (54) let -> LET ID ASSIGN operand . SEMICOLON

    SEMICOLON       shift and go to state 104


state 82

    (55) let -> LET ID ASSIGN bool . SEMICOLON

    SEMICOLON       shift and go to state 105


state 83

    (62) operand -> INT .

    SEMICOLON       reduce using rule 62 (operand -> INT .)
    COMMA           reduce using rule 62 (operand -> INT .)
    RPAREN          reduce using rule 62 (operand -> INT .)


state 84

    (63) operand -> opera .

    SEMICOLON       reduce using rule 63 (operand -> opera .)
    COMMA           reduce using rule 63 (operand -> opera .)
    RPAREN          reduce using rule 63 (operand -> opera .)


state 85

    (65) bool -> TRUE .

    SEMICOLON       reduce using rule 65 (bool -> TRUE .)
    RPAREN          reduce using rule 65 (bool -> TRUE .)


state 86

    (66) bool -> FALSE .

    SEMICOLON       reduce using rule 66 (bool -> FALSE .)
    RPAREN          reduce using rule 66 (bool -> FALSE .)


state 87

    (18) move -> MOVE LPAREN STRING COMMA . bool RPAREN SEMICOLON
    (65) bool -> . TRUE
    (66) bool -> . FALSE
    (67) bool -> . ID

    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 107

    bool                           shift and go to state 106

state 88

    (19) moveList -> MOVE LPAREN LSQRBRACKET fingerList . RSQRBRACKET COMMA bool RPAREN SEMICOLON

    RSQRBRACKET     shift and go to state 108


state 89

    (20) fingerList -> STRING . COMMA STRING
    (21) fingerList -> STRING . COMMA fingerList

    COMMA           shift and go to state 109


state 90

    (22) delay -> DELAY LPAREN INT COMMA . STRING RPAREN SEMICOLON

    STRING          shift and go to state 110


state 91

    (26) println -> PRINT EXPR LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 111


state 92

    (27) args -> INT . body
    (33) body -> . COMMA args
    (34) body -> . COMMA body
    (35) body -> . empty empty
    (69) empty -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 69 (empty -> .)

    body                           shift and go to state 112
    empty                          shift and go to state 114

state 93

    (28) args -> ID . body
    (33) body -> . COMMA args
    (34) body -> . COMMA body
    (35) body -> . empty empty
    (69) empty -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 69 (empty -> .)

    body                           shift and go to state 115
    empty                          shift and go to state 114

state 94

    (29) args -> opera . body
    (33) body -> . COMMA args
    (34) body -> . COMMA body
    (35) body -> . empty empty
    (69) empty -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 69 (empty -> .)

    body                           shift and go to state 116
    empty                          shift and go to state 114

state 95

    (30) args -> TRUE . body
    (33) body -> . COMMA args
    (34) body -> . COMMA body
    (35) body -> . empty empty
    (69) empty -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 69 (empty -> .)

    body                           shift and go to state 117
    empty                          shift and go to state 114

state 96

    (31) args -> FALSE . body
    (33) body -> . COMMA args
    (34) body -> . COMMA body
    (35) body -> . empty empty
    (69) empty -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 69 (empty -> .)

    body                           shift and go to state 118
    empty                          shift and go to state 114

state 97

    (32) args -> STRING . body
    (33) body -> . COMMA args
    (34) body -> . COMMA body
    (35) body -> . empty empty
    (69) empty -> .

    COMMA           shift and go to state 113
    RPAREN          reduce using rule 69 (empty -> .)

    body                           shift and go to state 119
    empty                          shift and go to state 114

state 98

    (13) main -> FN MAIN LPAREN RPAREN LCRLBRACKET . line RCRLBRACKET
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 120
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 99

    (15) for -> FOR ID IN INT DOTDOT . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 121


state 100

    (16) while -> WHILE LPAREN expression compare expression . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 122


state 101

    (17) while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 17 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)


state 102

    (39) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET
    (40) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 123
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 103

    (56) opera -> OPERA LPAREN operator COMMA . operand COMMA operand RPAREN
    (62) operand -> . INT
    (63) operand -> . opera
    (64) operand -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 83
    ID              shift and go to state 125
    OPERA           shift and go to state 46

    operand                        shift and go to state 124
    opera                          shift and go to state 84

state 104

    (54) let -> LET ID ASSIGN operand SEMICOLON .

    FN              reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    LOOP            reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    FOR             reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    WHILE           reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    IF              reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    LET             reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    MOVE            reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    DELAY           reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    PRINT           reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    BREAK           reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    $end            reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)
    RCRLBRACKET     reduce using rule 54 (let -> LET ID ASSIGN operand SEMICOLON .)


state 105

    (55) let -> LET ID ASSIGN bool SEMICOLON .

    FN              reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    LOOP            reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    FOR             reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    WHILE           reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    IF              reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    LET             reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    MOVE            reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    DELAY           reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    PRINT           reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    BREAK           reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    $end            reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)
    RCRLBRACKET     reduce using rule 55 (let -> LET ID ASSIGN bool SEMICOLON .)


state 106

    (18) move -> MOVE LPAREN STRING COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 126


state 107

    (67) bool -> ID .

    RPAREN          reduce using rule 67 (bool -> ID .)


state 108

    (19) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 127


state 109

    (20) fingerList -> STRING COMMA . STRING
    (21) fingerList -> STRING COMMA . fingerList
    (20) fingerList -> . STRING COMMA STRING
    (21) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 128

    fingerList                     shift and go to state 129

state 110

    (22) delay -> DELAY LPAREN INT COMMA STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 130


state 111

    (26) println -> PRINT EXPR LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 131


state 112

    (27) args -> INT body .

    RPAREN          reduce using rule 27 (args -> INT body .)


state 113

    (33) body -> COMMA . args
    (34) body -> COMMA . body
    (27) args -> . INT body
    (28) args -> . ID body
    (29) args -> . opera body
    (30) args -> . TRUE body
    (31) args -> . FALSE body
    (32) args -> . STRING body
    (33) body -> . COMMA args
    (34) body -> . COMMA body
    (35) body -> . empty empty
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (69) empty -> .

    INT             shift and go to state 92
    ID              shift and go to state 93
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    STRING          shift and go to state 97
    COMMA           shift and go to state 113
    OPERA           shift and go to state 46
    RPAREN          reduce using rule 69 (empty -> .)

    args                           shift and go to state 132
    body                           shift and go to state 133
    opera                          shift and go to state 94
    empty                          shift and go to state 114

state 114

    (35) body -> empty . empty
    (69) empty -> .

    RPAREN          reduce using rule 69 (empty -> .)

    empty                          shift and go to state 134

state 115

    (28) args -> ID body .

    RPAREN          reduce using rule 28 (args -> ID body .)


state 116

    (29) args -> opera body .

    RPAREN          reduce using rule 29 (args -> opera body .)


state 117

    (30) args -> TRUE body .

    RPAREN          reduce using rule 30 (args -> TRUE body .)


state 118

    (31) args -> FALSE body .

    RPAREN          reduce using rule 31 (args -> FALSE body .)


state 119

    (32) args -> STRING body .

    RPAREN          reduce using rule 32 (args -> STRING body .)


state 120

    (13) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 135


state 121

    (15) for -> FOR ID IN INT DOTDOT INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 136


state 122

    (16) while -> WHILE LPAREN expression compare expression RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 137


state 123

    (39) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET
    (40) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 138


state 124

    (56) opera -> OPERA LPAREN operator COMMA operand . COMMA operand RPAREN

    COMMA           shift and go to state 139


state 125

    (64) operand -> ID .

    COMMA           reduce using rule 64 (operand -> ID .)
    RPAREN          reduce using rule 64 (operand -> ID .)


state 126

    (18) move -> MOVE LPAREN STRING COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 140


state 127

    (19) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA . bool RPAREN SEMICOLON
    (65) bool -> . TRUE
    (66) bool -> . FALSE
    (67) bool -> . ID

    TRUE            shift and go to state 85
    FALSE           shift and go to state 86
    ID              shift and go to state 107

    bool                           shift and go to state 141

state 128

    (20) fingerList -> STRING COMMA STRING .
    (20) fingerList -> STRING . COMMA STRING
    (21) fingerList -> STRING . COMMA fingerList

    RSQRBRACKET     reduce using rule 20 (fingerList -> STRING COMMA STRING .)
    COMMA           shift and go to state 109


state 129

    (21) fingerList -> STRING COMMA fingerList .

    RSQRBRACKET     reduce using rule 21 (fingerList -> STRING COMMA fingerList .)


state 130

    (22) delay -> DELAY LPAREN INT COMMA STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 142


state 131

    (26) println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .

    FN              reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    LOOP            reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    LET             reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    MOVE            reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    DELAY           reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    PRINT           reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    BREAK           reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    $end            reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 26 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)


state 132

    (33) body -> COMMA args .

    RPAREN          reduce using rule 33 (body -> COMMA args .)


state 133

    (34) body -> COMMA body .

    RPAREN          reduce using rule 34 (body -> COMMA body .)


state 134

    (35) body -> empty empty .

    RPAREN          reduce using rule 35 (body -> empty empty .)


state 135

    (13) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 13 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)


state 136

    (15) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET . line RCRLBRACKET
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 143
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 137

    (16) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET . line RCRLBRACKET
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 144
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 138

    (39) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .
    (40) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (37) elseiforelse -> . elseif
    (38) elseiforelse -> . else
    (41) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line
    (42) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (43) else -> . ELSE LCRLBRACKET line RCRLBRACKET line

    FN              reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 39 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET .)
    ELSEIF          shift and go to state 148
    ELSE            shift and go to state 149

    elseiforelse                   shift and go to state 145
    elseif                         shift and go to state 146
    else                           shift and go to state 147

state 139

    (56) opera -> OPERA LPAREN operator COMMA operand COMMA . operand RPAREN
    (62) operand -> . INT
    (63) operand -> . opera
    (64) operand -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 83
    ID              shift and go to state 125
    OPERA           shift and go to state 46

    operand                        shift and go to state 150
    opera                          shift and go to state 84

state 140

    (18) move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .

    FN              reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    LOOP            reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    $end            reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 18 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)


state 141

    (19) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 151


state 142

    (22) delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .

    FN              reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    LOOP            reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    IF              reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    LET             reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    MOVE            reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    DELAY           reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    PRINT           reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    BREAK           reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    $end            reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 22 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)


state 143

    (15) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 152


state 144

    (16) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 153


state 145

    (40) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    FN              reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LOOP            reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    $end            reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 40 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)


state 146

    (37) elseiforelse -> elseif .

    $end            reduce using rule 37 (elseiforelse -> elseif .)
    RCRLBRACKET     reduce using rule 37 (elseiforelse -> elseif .)
    FN              reduce using rule 37 (elseiforelse -> elseif .)
    LOOP            reduce using rule 37 (elseiforelse -> elseif .)
    FOR             reduce using rule 37 (elseiforelse -> elseif .)
    WHILE           reduce using rule 37 (elseiforelse -> elseif .)
    IF              reduce using rule 37 (elseiforelse -> elseif .)
    LET             reduce using rule 37 (elseiforelse -> elseif .)
    MOVE            reduce using rule 37 (elseiforelse -> elseif .)
    DELAY           reduce using rule 37 (elseiforelse -> elseif .)
    PRINT           reduce using rule 37 (elseiforelse -> elseif .)
    BREAK           reduce using rule 37 (elseiforelse -> elseif .)


state 147

    (38) elseiforelse -> else .

    $end            reduce using rule 38 (elseiforelse -> else .)
    RCRLBRACKET     reduce using rule 38 (elseiforelse -> else .)
    FN              reduce using rule 38 (elseiforelse -> else .)
    LOOP            reduce using rule 38 (elseiforelse -> else .)
    FOR             reduce using rule 38 (elseiforelse -> else .)
    WHILE           reduce using rule 38 (elseiforelse -> else .)
    IF              reduce using rule 38 (elseiforelse -> else .)
    LET             reduce using rule 38 (elseiforelse -> else .)
    MOVE            reduce using rule 38 (elseiforelse -> else .)
    DELAY           reduce using rule 38 (elseiforelse -> else .)
    PRINT           reduce using rule 38 (elseiforelse -> else .)
    BREAK           reduce using rule 38 (elseiforelse -> else .)


state 148

    (41) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET line
    (42) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (49) expression -> . INT
    (50) expression -> . TRUE
    (51) expression -> . FALSE
    (52) expression -> . opera
    (53) expression -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 45
    OPERA           shift and go to state 46

    expression                     shift and go to state 154
    opera                          shift and go to state 44

state 149

    (43) else -> ELSE . LCRLBRACKET line RCRLBRACKET line

    LCRLBRACKET     shift and go to state 155


state 150

    (56) opera -> OPERA LPAREN operator COMMA operand COMMA operand . RPAREN

    RPAREN          shift and go to state 156


state 151

    (19) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 157


state 152

    (15) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 15 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)


state 153

    (16) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 16 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)


state 154

    (41) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET line
    (42) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (44) compare -> . EQEQ
    (45) compare -> . LTE
    (46) compare -> . GTE
    (47) compare -> . LT
    (48) compare -> . GT

    EQEQ            shift and go to state 57
    LTE             shift and go to state 58
    GTE             shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61

    compare                        shift and go to state 158

state 155

    (43) else -> ELSE LCRLBRACKET . line RCRLBRACKET line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 159
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 156

    (56) opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .

    EQEQ            reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LTE             reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GTE             reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LT              reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GT              reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LCRLBRACKET     reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    SEMICOLON       reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    COMMA           reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    RPAREN          reduce using rule 56 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)


state 157

    (19) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .

    FN              reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    LOOP            reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    $end            reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 19 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)


state 158

    (41) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET line
    (42) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (49) expression -> . INT
    (50) expression -> . TRUE
    (51) expression -> . FALSE
    (52) expression -> . opera
    (53) expression -> . ID
    (56) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 45
    OPERA           shift and go to state 46

    expression                     shift and go to state 160
    opera                          shift and go to state 44

state 159

    (43) else -> ELSE LCRLBRACKET line . RCRLBRACKET line

    RCRLBRACKET     shift and go to state 161


state 160

    (41) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET line
    (42) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 162


state 161

    (43) else -> ELSE LCRLBRACKET line RCRLBRACKET . line
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    line                           shift and go to state 163
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 162

    (41) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET line
    (42) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .

    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    RCRLBRACKET     reduce using rule 69 (empty -> .)

    line                           shift and go to state 164
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13

state 163

    (43) else -> ELSE LCRLBRACKET line RCRLBRACKET line .

    $end            reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    RCRLBRACKET     reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    FN              reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    LOOP            reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    FOR             reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    WHILE           reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    IF              reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    LET             reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    MOVE            reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    DELAY           reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    PRINT           reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)
    BREAK           reduce using rule 43 (else -> ELSE LCRLBRACKET line RCRLBRACKET line .)


state 164

    (41) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET line
    (42) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 165


state 165

    (41) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . line
    (42) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (1) line -> . main line
    (2) line -> . loop line
    (3) line -> . for line
    (4) line -> . while line
    (5) line -> . if line
    (6) line -> . let line
    (7) line -> . move line
    (8) line -> . moveList line
    (9) line -> . delay line
    (10) line -> . println line
    (11) line -> . break line
    (12) line -> . empty
    (37) elseiforelse -> . elseif
    (38) elseiforelse -> . else
    (13) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (14) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (15) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (16) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (17) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (39) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET
    (40) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (54) let -> . LET ID ASSIGN operand SEMICOLON
    (55) let -> . LET ID ASSIGN bool SEMICOLON
    (18) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (19) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (22) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (26) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (68) break -> . BREAK
    (69) empty -> .
    (41) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line
    (42) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (43) else -> . ELSE LCRLBRACKET line RCRLBRACKET line

  ! shift/reduce conflict for FN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for MOVE resolved as shift
  ! shift/reduce conflict for DELAY resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
    FN              shift and go to state 14
    LOOP            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    IF              shift and go to state 18
    LET             shift and go to state 19
    MOVE            shift and go to state 20
    DELAY           shift and go to state 21
    PRINT           shift and go to state 22
    BREAK           shift and go to state 23
    $end            reduce using rule 69 (empty -> .)
    RCRLBRACKET     reduce using rule 69 (empty -> .)
    ELSEIF          shift and go to state 148
    ELSE            shift and go to state 149

  ! FN              [ reduce using rule 69 (empty -> .) ]
  ! LOOP            [ reduce using rule 69 (empty -> .) ]
  ! FOR             [ reduce using rule 69 (empty -> .) ]
  ! WHILE           [ reduce using rule 69 (empty -> .) ]
  ! IF              [ reduce using rule 69 (empty -> .) ]
  ! LET             [ reduce using rule 69 (empty -> .) ]
  ! MOVE            [ reduce using rule 69 (empty -> .) ]
  ! DELAY           [ reduce using rule 69 (empty -> .) ]
  ! PRINT           [ reduce using rule 69 (empty -> .) ]
  ! BREAK           [ reduce using rule 69 (empty -> .) ]

    line                           shift and go to state 166
    elseiforelse                   shift and go to state 167
    main                           shift and go to state 2
    loop                           shift and go to state 3
    for                            shift and go to state 4
    while                          shift and go to state 5
    if                             shift and go to state 6
    let                            shift and go to state 7
    move                           shift and go to state 8
    moveList                       shift and go to state 9
    delay                          shift and go to state 10
    println                        shift and go to state 11
    break                          shift and go to state 12
    empty                          shift and go to state 13
    elseif                         shift and go to state 146
    else                           shift and go to state 147

state 166

    (41) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .

    $end            reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    RCRLBRACKET     reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    FN              reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    LOOP            reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    FOR             reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    WHILE           reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    IF              reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    LET             reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    MOVE            reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    DELAY           reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    PRINT           reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)
    BREAK           reduce using rule 41 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET line .)


state 167

    (42) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    $end            reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LOOP            reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 42 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FN in state 2 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for LET in state 2 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 2 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 2 resolved as shift
WARNING: shift/reduce conflict for FN in state 3 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for LET in state 3 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 3 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 3 resolved as shift
WARNING: shift/reduce conflict for FN in state 4 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for LET in state 4 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 4 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 4 resolved as shift
WARNING: shift/reduce conflict for FN in state 5 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 5 resolved as shift
WARNING: shift/reduce conflict for FOR in state 5 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 5 resolved as shift
WARNING: shift/reduce conflict for IF in state 5 resolved as shift
WARNING: shift/reduce conflict for LET in state 5 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 5 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 5 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 5 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 5 resolved as shift
WARNING: shift/reduce conflict for FN in state 6 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 6 resolved as shift
WARNING: shift/reduce conflict for FOR in state 6 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 6 resolved as shift
WARNING: shift/reduce conflict for IF in state 6 resolved as shift
WARNING: shift/reduce conflict for LET in state 6 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 6 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 6 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 6 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 6 resolved as shift
WARNING: shift/reduce conflict for FN in state 7 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 7 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 7 resolved as shift
WARNING: shift/reduce conflict for FN in state 8 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 8 resolved as shift
WARNING: shift/reduce conflict for FOR in state 8 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 8 resolved as shift
WARNING: shift/reduce conflict for IF in state 8 resolved as shift
WARNING: shift/reduce conflict for LET in state 8 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 8 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 8 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 8 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 8 resolved as shift
WARNING: shift/reduce conflict for FN in state 9 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for LET in state 9 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 9 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 9 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 9 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 9 resolved as shift
WARNING: shift/reduce conflict for FN in state 10 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 10 resolved as shift
WARNING: shift/reduce conflict for FOR in state 10 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 10 resolved as shift
WARNING: shift/reduce conflict for IF in state 10 resolved as shift
WARNING: shift/reduce conflict for LET in state 10 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 10 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 10 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 10 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 10 resolved as shift
WARNING: shift/reduce conflict for FN in state 11 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 11 resolved as shift
WARNING: shift/reduce conflict for FOR in state 11 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 11 resolved as shift
WARNING: shift/reduce conflict for IF in state 11 resolved as shift
WARNING: shift/reduce conflict for LET in state 11 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 11 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 11 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 11 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 11 resolved as shift
WARNING: shift/reduce conflict for FN in state 12 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 12 resolved as shift
WARNING: shift/reduce conflict for FOR in state 12 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 12 resolved as shift
WARNING: shift/reduce conflict for IF in state 12 resolved as shift
WARNING: shift/reduce conflict for LET in state 12 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 12 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 12 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 12 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 12 resolved as shift
WARNING: shift/reduce conflict for FN in state 161 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 161 resolved as shift
WARNING: shift/reduce conflict for FOR in state 161 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 161 resolved as shift
WARNING: shift/reduce conflict for IF in state 161 resolved as shift
WARNING: shift/reduce conflict for LET in state 161 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 161 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 161 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 161 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 161 resolved as shift
WARNING: shift/reduce conflict for FN in state 165 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 165 resolved as shift
WARNING: shift/reduce conflict for FOR in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for LET in state 165 resolved as shift
WARNING: shift/reduce conflict for MOVE in state 165 resolved as shift
WARNING: shift/reduce conflict for DELAY in state 165 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 165 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 165 resolved as shift
WARNING: reduce/reduce conflict in state 80 resolved using rule (operand -> ID)
WARNING: rejected rule (bool -> ID) in state 80
