Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOTDOTEQ
    RANGE
    WRONG_ID

Grammar

Rule 0     S' -> root
Rule 1     root -> main root
Rule 2     root -> function root
Rule 3     root -> procedure root
Rule 4     root -> let root
Rule 5     root -> empty empty
Rule 6     functions -> ID
Rule 7     main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
Rule 8     line -> loop line
Rule 9     line -> function line
Rule 10    line -> procedure line
Rule 11    line -> for line
Rule 12    line -> while line
Rule 13    line -> if line
Rule 14    line -> let line
Rule 15    line -> move line
Rule 16    line -> moveList line
Rule 17    line -> delay line
Rule 18    line -> println line
Rule 19    line -> break line
Rule 20    line -> empty empty
Rule 21    procedure -> FN ID LPAREN params RPAREN prodbody
Rule 22    prodbody -> LCRLBRACKET line RCRLBRACKET
Rule 23    function -> FN ID LPAREN params RPAREN funbody
Rule 24    params -> ID arg
Rule 25    params -> empty empty
Rule 26    arg -> COMMA params
Rule 27    arg -> COMMA arg
Rule 28    arg -> empty empty
Rule 29    funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET
Rule 30    output -> INTEGER
Rule 31    output -> BOOLEAN
Rule 32    end -> RETURN expression SEMICOLON
Rule 33    loop -> LOOP LCRLBRACKET line RCRLBRACKET
Rule 34    for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
Rule 35    while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
Rule 36    while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET
Rule 37    move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
Rule 38    moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
Rule 39    fingerList -> STRING COMMA STRING
Rule 40    fingerList -> STRING COMMA fingerList
Rule 41    delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
Rule 42    unit -> QUOT MIN QUOT
Rule 43    unit -> QUOT MIL QUOT
Rule 44    unit -> QUOT SEG QUOT
Rule 45    println -> PRINT EXPR LPAREN args RPAREN SEMICOLON
Rule 46    args -> INT body
Rule 47    args -> ID body
Rule 48    args -> opera body
Rule 49    args -> TRUE body
Rule 50    args -> FALSE body
Rule 51    args -> STRING body
Rule 52    body -> COMMA args
Rule 53    body -> COMMA body
Rule 54    body -> empty empty
Rule 55    text -> QUOT ID QUOT
Rule 56    elseiforelse -> elseif
Rule 57    elseiforelse -> else
Rule 58    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 59    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 60    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 61    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 62    else -> ELSE LCRLBRACKET line RCRLBRACKET
Rule 63    compare -> EQEQ
Rule 64    compare -> LTE
Rule 65    compare -> GTE
Rule 66    compare -> LT
Rule 67    compare -> GT
Rule 68    compare -> DIF
Rule 69    expression -> INT
Rule 70    expression -> TRUE
Rule 71    expression -> FALSE
Rule 72    expression -> opera
Rule 73    expression -> ID
Rule 74    expression -> negative
Rule 75    let -> LET ID ASSIGN operand SEMICOLON
Rule 76    let -> LET ID ASSIGN bool SEMICOLON
Rule 77    opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN
Rule 78    operator -> PLUS
Rule 79    operator -> MINUS
Rule 80    operator -> DIVIDE
Rule 81    operator -> ASTR
Rule 82    operator -> TIMES
Rule 83    operand -> INT
Rule 84    operand -> opera
Rule 85    operand -> ID
Rule 86    operand -> negative
Rule 87    negative -> MINUS INT
Rule 88    bool -> TRUE
Rule 89    bool -> FALSE
Rule 90    bool -> ID
Rule 91    break -> BREAK
Rule 92    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 29
ASSIGN               : 75 76
ASTR                 : 81
BOOLEAN              : 31
BREAK                : 91
COMMA                : 26 27 37 38 39 40 41 52 53 77 77
DELAY                : 41
DIF                  : 68
DIVIDE               : 80
DOTDOT               : 34
DOTDOTEQ             : 
ELSE                 : 62
ELSEIF               : 60 61
EQEQ                 : 63
EXPR                 : 45
FALSE                : 50 71 89
FN                   : 7 21 23
FOR                  : 34
GT                   : 67
GTE                  : 65
ID                   : 6 21 23 24 34 47 55 73 75 76 85 90
IF                   : 58 59
IN                   : 34
INT                  : 34 34 41 46 69 83 87
INTEGER              : 30
LCRLBRACKET          : 7 22 29 33 34 35 36 58 59 60 61 62
LET                  : 75 76
LOOP                 : 33
LPAREN               : 7 21 23 35 37 38 41 45 77
LSQRBRACKET          : 38
LT                   : 66
LTE                  : 64
MAIN                 : 7
MIL                  : 43
MIN                  : 42
MINUS                : 79 87
MOVE                 : 37 38
OPERA                : 77
PLUS                 : 78
PRINT                : 45
QUOT                 : 42 42 43 43 44 44 55 55
RANGE                : 
RCRLBRACKET          : 7 22 29 33 34 35 36 58 59 60 61 62
RETURN               : 32
RPAREN               : 7 21 23 35 37 38 41 45 77
RSQRBRACKET          : 38
SEG                  : 44
SEMICOLON            : 32 37 38 41 45 75 76
STRING               : 37 39 39 40 41 51
TIMES                : 82
TRUE                 : 36 49 70 88
WHILE                : 35 36
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

arg                  : 24 27
args                 : 45 52
body                 : 46 47 48 49 50 51 53
bool                 : 37 38 76
break                : 19
compare              : 35 58 59 60 61
delay                : 17
else                 : 57
elseif               : 56
elseiforelse         : 59 61
empty                : 5 5 20 20 25 25 28 28 54 54 58 60
end                  : 29
expression           : 32 35 35 58 58 59 59 60 60 61 61
fingerList           : 38 40
for                  : 11
funbody              : 23
function             : 2 9
functions            : 
if                   : 13
let                  : 4 14
line                 : 7 8 9 10 11 12 13 14 15 16 17 18 19 22 29 33 34 35 36 58 59 60 61 62
loop                 : 8
main                 : 1
move                 : 15
moveList             : 16
negative             : 74 86
opera                : 48 72 84
operand              : 75 77 77
operator             : 77
output               : 29
params               : 21 23 26
println              : 18
procedure            : 3 10
prodbody             : 21
root                 : 1 2 3 4 0
text                 : 
unit                 : 
while                : 12

Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (92) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 92 (empty -> .)

    root                           shift and go to state 1
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 1

    (0) S' -> root .



state 2

    (1) root -> main . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (92) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 92 (empty -> .)

    main                           shift and go to state 2
    root                           shift and go to state 9
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) root -> function . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (92) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 92 (empty -> .)

    function                       shift and go to state 3
    root                           shift and go to state 10
    main                           shift and go to state 2
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 4

    (3) root -> procedure . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (92) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 92 (empty -> .)

    procedure                      shift and go to state 4
    root                           shift and go to state 11
    main                           shift and go to state 2
    function                       shift and go to state 3
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 5

    (4) root -> let . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (92) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 92 (empty -> .)

    let                            shift and go to state 5
    root                           shift and go to state 12
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    empty                          shift and go to state 6

state 6

    (5) root -> empty . empty
    (92) empty -> .

    $end            reduce using rule 92 (empty -> .)

    empty                          shift and go to state 13

state 7

    (7) main -> FN . MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> FN . ID LPAREN params RPAREN funbody
    (21) procedure -> FN . ID LPAREN params RPAREN prodbody

    MAIN            shift and go to state 14
    ID              shift and go to state 15


state 8

    (75) let -> LET . ID ASSIGN operand SEMICOLON
    (76) let -> LET . ID ASSIGN bool SEMICOLON

    ID              shift and go to state 16


state 9

    (1) root -> main root .

    $end            reduce using rule 1 (root -> main root .)


state 10

    (2) root -> function root .

    $end            reduce using rule 2 (root -> function root .)


state 11

    (3) root -> procedure root .

    $end            reduce using rule 3 (root -> procedure root .)


state 12

    (4) root -> let root .

    $end            reduce using rule 4 (root -> let root .)


state 13

    (5) root -> empty empty .

    $end            reduce using rule 5 (root -> empty empty .)


state 14

    (7) main -> FN MAIN . LPAREN RPAREN LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 17


state 15

    (23) function -> FN ID . LPAREN params RPAREN funbody
    (21) procedure -> FN ID . LPAREN params RPAREN prodbody

    LPAREN          shift and go to state 18


state 16

    (75) let -> LET ID . ASSIGN operand SEMICOLON
    (76) let -> LET ID . ASSIGN bool SEMICOLON

    ASSIGN          shift and go to state 19


state 17

    (7) main -> FN MAIN LPAREN . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 20


state 18

    (23) function -> FN ID LPAREN . params RPAREN funbody
    (21) procedure -> FN ID LPAREN . params RPAREN prodbody
    (24) params -> . ID arg
    (25) params -> . empty empty
    (92) empty -> .

    ID              shift and go to state 21
    RPAREN          reduce using rule 92 (empty -> .)

    params                         shift and go to state 22
    empty                          shift and go to state 23

state 19

    (75) let -> LET ID ASSIGN . operand SEMICOLON
    (76) let -> LET ID ASSIGN . bool SEMICOLON
    (83) operand -> . INT
    (84) operand -> . opera
    (85) operand -> . ID
    (86) operand -> . negative
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (90) bool -> . ID
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 27
    ID              shift and go to state 24
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    operand                        shift and go to state 25
    bool                           shift and go to state 26
    opera                          shift and go to state 28
    negative                       shift and go to state 29

state 20

    (7) main -> FN MAIN LPAREN RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 34


state 21

    (24) params -> ID . arg
    (26) arg -> . COMMA params
    (27) arg -> . COMMA arg
    (28) arg -> . empty empty
    (92) empty -> .

    COMMA           shift and go to state 36
    RPAREN          reduce using rule 92 (empty -> .)

    arg                            shift and go to state 35
    empty                          shift and go to state 37

state 22

    (23) function -> FN ID LPAREN params . RPAREN funbody
    (21) procedure -> FN ID LPAREN params . RPAREN prodbody

    RPAREN          shift and go to state 38


state 23

    (25) params -> empty . empty
    (92) empty -> .

    RPAREN          reduce using rule 92 (empty -> .)

    empty                          shift and go to state 39

state 24

    (85) operand -> ID .
    (90) bool -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 85 (operand -> ID .)
    SEMICOLON       reduce using rule 85 (operand -> ID .)

  ! SEMICOLON       [ reduce using rule 90 (bool -> ID .) ]


state 25

    (75) let -> LET ID ASSIGN operand . SEMICOLON

    SEMICOLON       shift and go to state 40


state 26

    (76) let -> LET ID ASSIGN bool . SEMICOLON

    SEMICOLON       shift and go to state 41


state 27

    (83) operand -> INT .

    SEMICOLON       reduce using rule 83 (operand -> INT .)
    COMMA           reduce using rule 83 (operand -> INT .)
    RPAREN          reduce using rule 83 (operand -> INT .)


state 28

    (84) operand -> opera .

    SEMICOLON       reduce using rule 84 (operand -> opera .)
    COMMA           reduce using rule 84 (operand -> opera .)
    RPAREN          reduce using rule 84 (operand -> opera .)


state 29

    (86) operand -> negative .

    SEMICOLON       reduce using rule 86 (operand -> negative .)
    COMMA           reduce using rule 86 (operand -> negative .)
    RPAREN          reduce using rule 86 (operand -> negative .)


state 30

    (88) bool -> TRUE .

    SEMICOLON       reduce using rule 88 (bool -> TRUE .)
    RPAREN          reduce using rule 88 (bool -> TRUE .)


state 31

    (89) bool -> FALSE .

    SEMICOLON       reduce using rule 89 (bool -> FALSE .)
    RPAREN          reduce using rule 89 (bool -> FALSE .)


state 32

    (77) opera -> OPERA . LPAREN operator COMMA operand COMMA operand RPAREN

    LPAREN          shift and go to state 42


state 33

    (87) negative -> MINUS . INT

    INT             shift and go to state 43


state 34

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 45
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 35

    (24) params -> ID arg .

    RPAREN          reduce using rule 24 (params -> ID arg .)


state 36

    (26) arg -> COMMA . params
    (27) arg -> COMMA . arg
    (24) params -> . ID arg
    (25) params -> . empty empty
    (26) arg -> . COMMA params
    (27) arg -> . COMMA arg
    (28) arg -> . empty empty
    (92) empty -> .

    ID              shift and go to state 21
    COMMA           shift and go to state 36
    RPAREN          reduce using rule 92 (empty -> .)

    params                         shift and go to state 67
    arg                            shift and go to state 68
    empty                          shift and go to state 69

state 37

    (28) arg -> empty . empty
    (92) empty -> .

    RPAREN          reduce using rule 92 (empty -> .)

    empty                          shift and go to state 70

state 38

    (23) function -> FN ID LPAREN params RPAREN . funbody
    (21) procedure -> FN ID LPAREN params RPAREN . prodbody
    (29) funbody -> . ARROW output LCRLBRACKET line end RCRLBRACKET
    (22) prodbody -> . LCRLBRACKET line RCRLBRACKET

    ARROW           shift and go to state 73
    LCRLBRACKET     shift and go to state 74

    funbody                        shift and go to state 71
    prodbody                       shift and go to state 72

state 39

    (25) params -> empty empty .

    RPAREN          reduce using rule 25 (params -> empty empty .)


state 40

    (75) let -> LET ID ASSIGN operand SEMICOLON .

    FN              reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    LET             reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    $end            reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    LOOP            reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    FOR             reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    WHILE           reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    IF              reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    MOVE            reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    DELAY           reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    PRINT           reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    BREAK           reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    RCRLBRACKET     reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)
    RETURN          reduce using rule 75 (let -> LET ID ASSIGN operand SEMICOLON .)


state 41

    (76) let -> LET ID ASSIGN bool SEMICOLON .

    FN              reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    LET             reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    $end            reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    LOOP            reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    FOR             reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    WHILE           reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    IF              reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    MOVE            reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    DELAY           reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    PRINT           reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    BREAK           reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    RCRLBRACKET     reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)
    RETURN          reduce using rule 76 (let -> LET ID ASSIGN bool SEMICOLON .)


state 42

    (77) opera -> OPERA LPAREN . operator COMMA operand COMMA operand RPAREN
    (78) operator -> . PLUS
    (79) operator -> . MINUS
    (80) operator -> . DIVIDE
    (81) operator -> . ASTR
    (82) operator -> . TIMES

    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    DIVIDE          shift and go to state 78
    ASTR            shift and go to state 79
    TIMES           shift and go to state 80

    operator                       shift and go to state 75

state 43

    (87) negative -> MINUS INT .

    SEMICOLON       reduce using rule 87 (negative -> MINUS INT .)
    EQEQ            reduce using rule 87 (negative -> MINUS INT .)
    LTE             reduce using rule 87 (negative -> MINUS INT .)
    GTE             reduce using rule 87 (negative -> MINUS INT .)
    LT              reduce using rule 87 (negative -> MINUS INT .)
    GT              reduce using rule 87 (negative -> MINUS INT .)
    DIF             reduce using rule 87 (negative -> MINUS INT .)
    COMMA           reduce using rule 87 (negative -> MINUS INT .)
    LCRLBRACKET     reduce using rule 87 (negative -> MINUS INT .)
    RPAREN          reduce using rule 87 (negative -> MINUS INT .)


state 44

    (23) function -> FN . ID LPAREN params RPAREN funbody
    (21) procedure -> FN . ID LPAREN params RPAREN prodbody

    ID              shift and go to state 15


state 45

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 81


state 46

    (8) line -> loop . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    loop                           shift and go to state 46
    line                           shift and go to state 82
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 47

    (9) line -> function . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    function                       shift and go to state 47
    line                           shift and go to state 83
    loop                           shift and go to state 46
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 48

    (10) line -> procedure . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    procedure                      shift and go to state 48
    line                           shift and go to state 84
    loop                           shift and go to state 46
    function                       shift and go to state 47
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 49

    (11) line -> for . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    for                            shift and go to state 49
    line                           shift and go to state 85
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 50

    (12) line -> while . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    while                          shift and go to state 50
    line                           shift and go to state 86
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 51

    (13) line -> if . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    if                             shift and go to state 51
    line                           shift and go to state 87
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 52

    (14) line -> let . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    let                            shift and go to state 52
    line                           shift and go to state 88
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 53

    (15) line -> move . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    move                           shift and go to state 53
    line                           shift and go to state 89
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 54

    (16) line -> moveList . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    moveList                       shift and go to state 54
    line                           shift and go to state 90
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 55

    (17) line -> delay . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    delay                          shift and go to state 55
    line                           shift and go to state 91
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 56

    (18) line -> println . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    println                        shift and go to state 56
    line                           shift and go to state 92
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 57

    (19) line -> break . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    break                          shift and go to state 57
    line                           shift and go to state 93
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    empty                          shift and go to state 58

state 58

    (20) line -> empty . empty
    (92) empty -> .

    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)

    empty                          shift and go to state 94

state 59

    (33) loop -> LOOP . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 95


state 60

    (34) for -> FOR . ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    ID              shift and go to state 96


state 61

    (35) while -> WHILE . LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> WHILE . TRUE LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 97
    TRUE            shift and go to state 98


state 62

    (58) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (69) expression -> . INT
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . opera
    (73) expression -> . ID
    (74) expression -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 99
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 63

    (37) move -> MOVE . LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> MOVE . LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    LPAREN          shift and go to state 106


state 64

    (41) delay -> DELAY . LPAREN INT COMMA STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 107


state 65

    (45) println -> PRINT . EXPR LPAREN args RPAREN SEMICOLON

    EXPR            shift and go to state 108


state 66

    (91) break -> BREAK .

    LOOP            reduce using rule 91 (break -> BREAK .)
    FN              reduce using rule 91 (break -> BREAK .)
    FOR             reduce using rule 91 (break -> BREAK .)
    WHILE           reduce using rule 91 (break -> BREAK .)
    IF              reduce using rule 91 (break -> BREAK .)
    LET             reduce using rule 91 (break -> BREAK .)
    MOVE            reduce using rule 91 (break -> BREAK .)
    DELAY           reduce using rule 91 (break -> BREAK .)
    PRINT           reduce using rule 91 (break -> BREAK .)
    BREAK           reduce using rule 91 (break -> BREAK .)
    RCRLBRACKET     reduce using rule 91 (break -> BREAK .)
    RETURN          reduce using rule 91 (break -> BREAK .)


state 67

    (26) arg -> COMMA params .

    RPAREN          reduce using rule 26 (arg -> COMMA params .)


state 68

    (27) arg -> COMMA arg .

    RPAREN          reduce using rule 27 (arg -> COMMA arg .)


state 69

    (25) params -> empty . empty
    (28) arg -> empty . empty
    (92) empty -> .

    RPAREN          reduce using rule 92 (empty -> .)

    empty                          shift and go to state 109

state 70

    (28) arg -> empty empty .

    RPAREN          reduce using rule 28 (arg -> empty empty .)


state 71

    (23) function -> FN ID LPAREN params RPAREN funbody .

    FN              reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    LET             reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    $end            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    LOOP            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    FOR             reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    WHILE           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    IF              reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    MOVE            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    DELAY           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    PRINT           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    BREAK           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    RCRLBRACKET     reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    RETURN          reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)


state 72

    (21) procedure -> FN ID LPAREN params RPAREN prodbody .

    FN              reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LET             reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    $end            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LOOP            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    FOR             reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    WHILE           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    IF              reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    MOVE            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    DELAY           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    PRINT           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    BREAK           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RCRLBRACKET     reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RETURN          reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)


state 73

    (29) funbody -> ARROW . output LCRLBRACKET line end RCRLBRACKET
    (30) output -> . INTEGER
    (31) output -> . BOOLEAN

    INTEGER         shift and go to state 111
    BOOLEAN         shift and go to state 112

    output                         shift and go to state 110

state 74

    (22) prodbody -> LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 113
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 75

    (77) opera -> OPERA LPAREN operator . COMMA operand COMMA operand RPAREN

    COMMA           shift and go to state 114


state 76

    (78) operator -> PLUS .

    COMMA           reduce using rule 78 (operator -> PLUS .)


state 77

    (79) operator -> MINUS .

    COMMA           reduce using rule 79 (operator -> MINUS .)


state 78

    (80) operator -> DIVIDE .

    COMMA           reduce using rule 80 (operator -> DIVIDE .)


state 79

    (81) operator -> ASTR .

    COMMA           reduce using rule 81 (operator -> ASTR .)


state 80

    (82) operator -> TIMES .

    COMMA           reduce using rule 82 (operator -> TIMES .)


state 81

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)


state 82

    (8) line -> loop line .

    RCRLBRACKET     reduce using rule 8 (line -> loop line .)
    RETURN          reduce using rule 8 (line -> loop line .)


state 83

    (9) line -> function line .

    RCRLBRACKET     reduce using rule 9 (line -> function line .)
    RETURN          reduce using rule 9 (line -> function line .)


state 84

    (10) line -> procedure line .

    RCRLBRACKET     reduce using rule 10 (line -> procedure line .)
    RETURN          reduce using rule 10 (line -> procedure line .)


state 85

    (11) line -> for line .

    RCRLBRACKET     reduce using rule 11 (line -> for line .)
    RETURN          reduce using rule 11 (line -> for line .)


state 86

    (12) line -> while line .

    RCRLBRACKET     reduce using rule 12 (line -> while line .)
    RETURN          reduce using rule 12 (line -> while line .)


state 87

    (13) line -> if line .

    RCRLBRACKET     reduce using rule 13 (line -> if line .)
    RETURN          reduce using rule 13 (line -> if line .)


state 88

    (14) line -> let line .

    RCRLBRACKET     reduce using rule 14 (line -> let line .)
    RETURN          reduce using rule 14 (line -> let line .)


state 89

    (15) line -> move line .

    RCRLBRACKET     reduce using rule 15 (line -> move line .)
    RETURN          reduce using rule 15 (line -> move line .)


state 90

    (16) line -> moveList line .

    RCRLBRACKET     reduce using rule 16 (line -> moveList line .)
    RETURN          reduce using rule 16 (line -> moveList line .)


state 91

    (17) line -> delay line .

    RCRLBRACKET     reduce using rule 17 (line -> delay line .)
    RETURN          reduce using rule 17 (line -> delay line .)


state 92

    (18) line -> println line .

    RCRLBRACKET     reduce using rule 18 (line -> println line .)
    RETURN          reduce using rule 18 (line -> println line .)


state 93

    (19) line -> break line .

    RCRLBRACKET     reduce using rule 19 (line -> break line .)
    RETURN          reduce using rule 19 (line -> break line .)


state 94

    (20) line -> empty empty .

    RCRLBRACKET     reduce using rule 20 (line -> empty empty .)
    RETURN          reduce using rule 20 (line -> empty empty .)


state 95

    (33) loop -> LOOP LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 115
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 96

    (34) for -> FOR ID . IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    IN              shift and go to state 116


state 97

    (35) while -> WHILE LPAREN . expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (69) expression -> . INT
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . opera
    (73) expression -> . ID
    (74) expression -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 117
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 98

    (36) while -> WHILE TRUE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 118


state 99

    (58) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT
    (68) compare -> . DIF

    EQEQ            shift and go to state 120
    LTE             shift and go to state 121
    GTE             shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    DIF             shift and go to state 125

    compare                        shift and go to state 119

state 100

    (69) expression -> INT .

    EQEQ            reduce using rule 69 (expression -> INT .)
    LTE             reduce using rule 69 (expression -> INT .)
    GTE             reduce using rule 69 (expression -> INT .)
    LT              reduce using rule 69 (expression -> INT .)
    GT              reduce using rule 69 (expression -> INT .)
    DIF             reduce using rule 69 (expression -> INT .)
    LCRLBRACKET     reduce using rule 69 (expression -> INT .)
    RPAREN          reduce using rule 69 (expression -> INT .)
    SEMICOLON       reduce using rule 69 (expression -> INT .)


state 101

    (70) expression -> TRUE .

    EQEQ            reduce using rule 70 (expression -> TRUE .)
    LTE             reduce using rule 70 (expression -> TRUE .)
    GTE             reduce using rule 70 (expression -> TRUE .)
    LT              reduce using rule 70 (expression -> TRUE .)
    GT              reduce using rule 70 (expression -> TRUE .)
    DIF             reduce using rule 70 (expression -> TRUE .)
    LCRLBRACKET     reduce using rule 70 (expression -> TRUE .)
    RPAREN          reduce using rule 70 (expression -> TRUE .)
    SEMICOLON       reduce using rule 70 (expression -> TRUE .)


state 102

    (71) expression -> FALSE .

    EQEQ            reduce using rule 71 (expression -> FALSE .)
    LTE             reduce using rule 71 (expression -> FALSE .)
    GTE             reduce using rule 71 (expression -> FALSE .)
    LT              reduce using rule 71 (expression -> FALSE .)
    GT              reduce using rule 71 (expression -> FALSE .)
    DIF             reduce using rule 71 (expression -> FALSE .)
    LCRLBRACKET     reduce using rule 71 (expression -> FALSE .)
    RPAREN          reduce using rule 71 (expression -> FALSE .)
    SEMICOLON       reduce using rule 71 (expression -> FALSE .)


state 103

    (72) expression -> opera .

    EQEQ            reduce using rule 72 (expression -> opera .)
    LTE             reduce using rule 72 (expression -> opera .)
    GTE             reduce using rule 72 (expression -> opera .)
    LT              reduce using rule 72 (expression -> opera .)
    GT              reduce using rule 72 (expression -> opera .)
    DIF             reduce using rule 72 (expression -> opera .)
    LCRLBRACKET     reduce using rule 72 (expression -> opera .)
    RPAREN          reduce using rule 72 (expression -> opera .)
    SEMICOLON       reduce using rule 72 (expression -> opera .)


state 104

    (73) expression -> ID .

    EQEQ            reduce using rule 73 (expression -> ID .)
    LTE             reduce using rule 73 (expression -> ID .)
    GTE             reduce using rule 73 (expression -> ID .)
    LT              reduce using rule 73 (expression -> ID .)
    GT              reduce using rule 73 (expression -> ID .)
    DIF             reduce using rule 73 (expression -> ID .)
    LCRLBRACKET     reduce using rule 73 (expression -> ID .)
    RPAREN          reduce using rule 73 (expression -> ID .)
    SEMICOLON       reduce using rule 73 (expression -> ID .)


state 105

    (74) expression -> negative .

    EQEQ            reduce using rule 74 (expression -> negative .)
    LTE             reduce using rule 74 (expression -> negative .)
    GTE             reduce using rule 74 (expression -> negative .)
    LT              reduce using rule 74 (expression -> negative .)
    GT              reduce using rule 74 (expression -> negative .)
    DIF             reduce using rule 74 (expression -> negative .)
    LCRLBRACKET     reduce using rule 74 (expression -> negative .)
    RPAREN          reduce using rule 74 (expression -> negative .)
    SEMICOLON       reduce using rule 74 (expression -> negative .)


state 106

    (37) move -> MOVE LPAREN . STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> MOVE LPAREN . LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    STRING          shift and go to state 126
    LSQRBRACKET     shift and go to state 127


state 107

    (41) delay -> DELAY LPAREN . INT COMMA STRING RPAREN SEMICOLON

    INT             shift and go to state 128


state 108

    (45) println -> PRINT EXPR . LPAREN args RPAREN SEMICOLON

    LPAREN          shift and go to state 129


state 109

    (25) params -> empty empty .
    (28) arg -> empty empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 25 (params -> empty empty .)
    RPAREN          reduce using rule 25 (params -> empty empty .)

  ! RPAREN          [ reduce using rule 28 (arg -> empty empty .) ]


state 110

    (29) funbody -> ARROW output . LCRLBRACKET line end RCRLBRACKET

    LCRLBRACKET     shift and go to state 130


state 111

    (30) output -> INTEGER .

    LCRLBRACKET     reduce using rule 30 (output -> INTEGER .)


state 112

    (31) output -> BOOLEAN .

    LCRLBRACKET     reduce using rule 31 (output -> BOOLEAN .)


state 113

    (22) prodbody -> LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 131


state 114

    (77) opera -> OPERA LPAREN operator COMMA . operand COMMA operand RPAREN
    (83) operand -> . INT
    (84) operand -> . opera
    (85) operand -> . ID
    (86) operand -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 27
    ID              shift and go to state 133
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    operand                        shift and go to state 132
    opera                          shift and go to state 28
    negative                       shift and go to state 29

state 115

    (33) loop -> LOOP LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 134


state 116

    (34) for -> FOR ID IN . INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 135


state 117

    (35) while -> WHILE LPAREN expression . compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT
    (68) compare -> . DIF

    EQEQ            shift and go to state 120
    LTE             shift and go to state 121
    GTE             shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    DIF             shift and go to state 125

    compare                        shift and go to state 136

state 118

    (36) while -> WHILE TRUE LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 137
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 119

    (58) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (69) expression -> . INT
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . opera
    (73) expression -> . ID
    (74) expression -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 138
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 120

    (63) compare -> EQEQ .

    INT             reduce using rule 63 (compare -> EQEQ .)
    TRUE            reduce using rule 63 (compare -> EQEQ .)
    FALSE           reduce using rule 63 (compare -> EQEQ .)
    ID              reduce using rule 63 (compare -> EQEQ .)
    OPERA           reduce using rule 63 (compare -> EQEQ .)
    MINUS           reduce using rule 63 (compare -> EQEQ .)


state 121

    (64) compare -> LTE .

    INT             reduce using rule 64 (compare -> LTE .)
    TRUE            reduce using rule 64 (compare -> LTE .)
    FALSE           reduce using rule 64 (compare -> LTE .)
    ID              reduce using rule 64 (compare -> LTE .)
    OPERA           reduce using rule 64 (compare -> LTE .)
    MINUS           reduce using rule 64 (compare -> LTE .)


state 122

    (65) compare -> GTE .

    INT             reduce using rule 65 (compare -> GTE .)
    TRUE            reduce using rule 65 (compare -> GTE .)
    FALSE           reduce using rule 65 (compare -> GTE .)
    ID              reduce using rule 65 (compare -> GTE .)
    OPERA           reduce using rule 65 (compare -> GTE .)
    MINUS           reduce using rule 65 (compare -> GTE .)


state 123

    (66) compare -> LT .

    INT             reduce using rule 66 (compare -> LT .)
    TRUE            reduce using rule 66 (compare -> LT .)
    FALSE           reduce using rule 66 (compare -> LT .)
    ID              reduce using rule 66 (compare -> LT .)
    OPERA           reduce using rule 66 (compare -> LT .)
    MINUS           reduce using rule 66 (compare -> LT .)


state 124

    (67) compare -> GT .

    INT             reduce using rule 67 (compare -> GT .)
    TRUE            reduce using rule 67 (compare -> GT .)
    FALSE           reduce using rule 67 (compare -> GT .)
    ID              reduce using rule 67 (compare -> GT .)
    OPERA           reduce using rule 67 (compare -> GT .)
    MINUS           reduce using rule 67 (compare -> GT .)


state 125

    (68) compare -> DIF .

    INT             reduce using rule 68 (compare -> DIF .)
    TRUE            reduce using rule 68 (compare -> DIF .)
    FALSE           reduce using rule 68 (compare -> DIF .)
    ID              reduce using rule 68 (compare -> DIF .)
    OPERA           reduce using rule 68 (compare -> DIF .)
    MINUS           reduce using rule 68 (compare -> DIF .)


state 126

    (37) move -> MOVE LPAREN STRING . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 139


state 127

    (38) moveList -> MOVE LPAREN LSQRBRACKET . fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (39) fingerList -> . STRING COMMA STRING
    (40) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 141

    fingerList                     shift and go to state 140

state 128

    (41) delay -> DELAY LPAREN INT . COMMA STRING RPAREN SEMICOLON

    COMMA           shift and go to state 142


state 129

    (45) println -> PRINT EXPR LPAREN . args RPAREN SEMICOLON
    (46) args -> . INT body
    (47) args -> . ID body
    (48) args -> . opera body
    (49) args -> . TRUE body
    (50) args -> . FALSE body
    (51) args -> . STRING body
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 144
    ID              shift and go to state 145
    TRUE            shift and go to state 147
    FALSE           shift and go to state 148
    STRING          shift and go to state 149
    OPERA           shift and go to state 32

    args                           shift and go to state 143
    opera                          shift and go to state 146

state 130

    (29) funbody -> ARROW output LCRLBRACKET . line end RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RETURN          reduce using rule 92 (empty -> .)

    line                           shift and go to state 150
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 131

    (22) prodbody -> LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)


state 132

    (77) opera -> OPERA LPAREN operator COMMA operand . COMMA operand RPAREN

    COMMA           shift and go to state 151


state 133

    (85) operand -> ID .

    COMMA           reduce using rule 85 (operand -> ID .)
    RPAREN          reduce using rule 85 (operand -> ID .)


state 134

    (33) loop -> LOOP LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)


state 135

    (34) for -> FOR ID IN INT . DOTDOT INT LCRLBRACKET line RCRLBRACKET

    DOTDOT          shift and go to state 152


state 136

    (35) while -> WHILE LPAREN expression compare . expression RPAREN LCRLBRACKET line RCRLBRACKET
    (69) expression -> . INT
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . opera
    (73) expression -> . ID
    (74) expression -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 153
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 137

    (36) while -> WHILE TRUE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 154


state 138

    (58) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 155


state 139

    (37) move -> MOVE LPAREN STRING COMMA . bool RPAREN SEMICOLON
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (90) bool -> . ID

    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 157

    bool                           shift and go to state 156

state 140

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList . RSQRBRACKET COMMA bool RPAREN SEMICOLON

    RSQRBRACKET     shift and go to state 158


state 141

    (39) fingerList -> STRING . COMMA STRING
    (40) fingerList -> STRING . COMMA fingerList

    COMMA           shift and go to state 159


state 142

    (41) delay -> DELAY LPAREN INT COMMA . STRING RPAREN SEMICOLON

    STRING          shift and go to state 160


state 143

    (45) println -> PRINT EXPR LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 161


state 144

    (46) args -> INT . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (92) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 92 (empty -> .)

    body                           shift and go to state 162
    empty                          shift and go to state 164

state 145

    (47) args -> ID . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (92) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 92 (empty -> .)

    body                           shift and go to state 165
    empty                          shift and go to state 164

state 146

    (48) args -> opera . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (92) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 92 (empty -> .)

    body                           shift and go to state 166
    empty                          shift and go to state 164

state 147

    (49) args -> TRUE . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (92) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 92 (empty -> .)

    body                           shift and go to state 167
    empty                          shift and go to state 164

state 148

    (50) args -> FALSE . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (92) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 92 (empty -> .)

    body                           shift and go to state 168
    empty                          shift and go to state 164

state 149

    (51) args -> STRING . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (92) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 92 (empty -> .)

    body                           shift and go to state 169
    empty                          shift and go to state 164

state 150

    (29) funbody -> ARROW output LCRLBRACKET line . end RCRLBRACKET
    (32) end -> . RETURN expression SEMICOLON

    RETURN          shift and go to state 171

    end                            shift and go to state 170

state 151

    (77) opera -> OPERA LPAREN operator COMMA operand COMMA . operand RPAREN
    (83) operand -> . INT
    (84) operand -> . opera
    (85) operand -> . ID
    (86) operand -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 27
    ID              shift and go to state 133
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    operand                        shift and go to state 172
    opera                          shift and go to state 28
    negative                       shift and go to state 29

state 152

    (34) for -> FOR ID IN INT DOTDOT . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 173


state 153

    (35) while -> WHILE LPAREN expression compare expression . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 174


state 154

    (36) while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)


state 155

    (58) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (59) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 175
    empty                          shift and go to state 58
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57

state 156

    (37) move -> MOVE LPAREN STRING COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 176


state 157

    (90) bool -> ID .

    RPAREN          reduce using rule 90 (bool -> ID .)


state 158

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 177


state 159

    (39) fingerList -> STRING COMMA . STRING
    (40) fingerList -> STRING COMMA . fingerList
    (39) fingerList -> . STRING COMMA STRING
    (40) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 178

    fingerList                     shift and go to state 179

state 160

    (41) delay -> DELAY LPAREN INT COMMA STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 180


state 161

    (45) println -> PRINT EXPR LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 181


state 162

    (46) args -> INT body .

    RPAREN          reduce using rule 46 (args -> INT body .)


state 163

    (52) body -> COMMA . args
    (53) body -> COMMA . body
    (46) args -> . INT body
    (47) args -> . ID body
    (48) args -> . opera body
    (49) args -> . TRUE body
    (50) args -> . FALSE body
    (51) args -> . STRING body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (92) empty -> .

    INT             shift and go to state 144
    ID              shift and go to state 145
    TRUE            shift and go to state 147
    FALSE           shift and go to state 148
    STRING          shift and go to state 149
    COMMA           shift and go to state 163
    OPERA           shift and go to state 32
    RPAREN          reduce using rule 92 (empty -> .)

    args                           shift and go to state 182
    body                           shift and go to state 183
    opera                          shift and go to state 146
    empty                          shift and go to state 164

state 164

    (54) body -> empty . empty
    (92) empty -> .

    RPAREN          reduce using rule 92 (empty -> .)

    empty                          shift and go to state 184

state 165

    (47) args -> ID body .

    RPAREN          reduce using rule 47 (args -> ID body .)


state 166

    (48) args -> opera body .

    RPAREN          reduce using rule 48 (args -> opera body .)


state 167

    (49) args -> TRUE body .

    RPAREN          reduce using rule 49 (args -> TRUE body .)


state 168

    (50) args -> FALSE body .

    RPAREN          reduce using rule 50 (args -> FALSE body .)


state 169

    (51) args -> STRING body .

    RPAREN          reduce using rule 51 (args -> STRING body .)


state 170

    (29) funbody -> ARROW output LCRLBRACKET line end . RCRLBRACKET

    RCRLBRACKET     shift and go to state 185


state 171

    (32) end -> RETURN . expression SEMICOLON
    (69) expression -> . INT
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . opera
    (73) expression -> . ID
    (74) expression -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 186
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 172

    (77) opera -> OPERA LPAREN operator COMMA operand COMMA operand . RPAREN

    RPAREN          shift and go to state 187


state 173

    (34) for -> FOR ID IN INT DOTDOT INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 188


state 174

    (35) while -> WHILE LPAREN expression compare expression RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 189


state 175

    (58) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (59) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 190


state 176

    (37) move -> MOVE LPAREN STRING COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 191


state 177

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA . bool RPAREN SEMICOLON
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (90) bool -> . ID

    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 157

    bool                           shift and go to state 192

state 178

    (39) fingerList -> STRING COMMA STRING .
    (39) fingerList -> STRING . COMMA STRING
    (40) fingerList -> STRING . COMMA fingerList

    RSQRBRACKET     reduce using rule 39 (fingerList -> STRING COMMA STRING .)
    COMMA           shift and go to state 159


state 179

    (40) fingerList -> STRING COMMA fingerList .

    RSQRBRACKET     reduce using rule 40 (fingerList -> STRING COMMA fingerList .)


state 180

    (41) delay -> DELAY LPAREN INT COMMA STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 193


state 181

    (45) println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .

    LOOP            reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FN              reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    LET             reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    MOVE            reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    DELAY           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    PRINT           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    BREAK           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)


state 182

    (52) body -> COMMA args .

    RPAREN          reduce using rule 52 (body -> COMMA args .)


state 183

    (53) body -> COMMA body .

    RPAREN          reduce using rule 53 (body -> COMMA body .)


state 184

    (54) body -> empty empty .

    RPAREN          reduce using rule 54 (body -> empty empty .)


state 185

    (29) funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .

    FN              reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LET             reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    $end            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LOOP            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    FOR             reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    WHILE           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    IF              reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    MOVE            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    DELAY           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    PRINT           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    BREAK           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RETURN          reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)


state 186

    (32) end -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 194


state 187

    (77) opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .

    SEMICOLON       reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    EQEQ            reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LTE             reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GTE             reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LT              reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GT              reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    DIF             reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    COMMA           reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LCRLBRACKET     reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    RPAREN          reduce using rule 77 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)


state 188

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 195
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 189

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 196
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 190

    (58) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (59) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (92) empty -> .
    (56) elseiforelse -> . elseif
    (57) elseiforelse -> . else
    (60) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (62) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 92 (empty -> .)
    FN              reduce using rule 92 (empty -> .)
    FOR             reduce using rule 92 (empty -> .)
    WHILE           reduce using rule 92 (empty -> .)
    IF              reduce using rule 92 (empty -> .)
    LET             reduce using rule 92 (empty -> .)
    MOVE            reduce using rule 92 (empty -> .)
    DELAY           reduce using rule 92 (empty -> .)
    PRINT           reduce using rule 92 (empty -> .)
    BREAK           reduce using rule 92 (empty -> .)
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)
    ELSEIF          shift and go to state 201
    ELSE            shift and go to state 202

    empty                          shift and go to state 197
    elseiforelse                   shift and go to state 198
    elseif                         shift and go to state 199
    else                           shift and go to state 200

state 191

    (37) move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)


state 192

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 203


state 193

    (41) delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .

    LOOP            reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FN              reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    IF              reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    LET             reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    MOVE            reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    DELAY           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    BREAK           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)


state 194

    (32) end -> RETURN expression SEMICOLON .

    RCRLBRACKET     reduce using rule 32 (end -> RETURN expression SEMICOLON .)


state 195

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 204


state 196

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 205


state 197

    (58) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 198

    (59) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)


state 199

    (56) elseiforelse -> elseif .

    LOOP            reduce using rule 56 (elseiforelse -> elseif .)
    FN              reduce using rule 56 (elseiforelse -> elseif .)
    FOR             reduce using rule 56 (elseiforelse -> elseif .)
    WHILE           reduce using rule 56 (elseiforelse -> elseif .)
    IF              reduce using rule 56 (elseiforelse -> elseif .)
    LET             reduce using rule 56 (elseiforelse -> elseif .)
    MOVE            reduce using rule 56 (elseiforelse -> elseif .)
    DELAY           reduce using rule 56 (elseiforelse -> elseif .)
    PRINT           reduce using rule 56 (elseiforelse -> elseif .)
    BREAK           reduce using rule 56 (elseiforelse -> elseif .)
    RCRLBRACKET     reduce using rule 56 (elseiforelse -> elseif .)
    RETURN          reduce using rule 56 (elseiforelse -> elseif .)


state 200

    (57) elseiforelse -> else .

    LOOP            reduce using rule 57 (elseiforelse -> else .)
    FN              reduce using rule 57 (elseiforelse -> else .)
    FOR             reduce using rule 57 (elseiforelse -> else .)
    WHILE           reduce using rule 57 (elseiforelse -> else .)
    IF              reduce using rule 57 (elseiforelse -> else .)
    LET             reduce using rule 57 (elseiforelse -> else .)
    MOVE            reduce using rule 57 (elseiforelse -> else .)
    DELAY           reduce using rule 57 (elseiforelse -> else .)
    PRINT           reduce using rule 57 (elseiforelse -> else .)
    BREAK           reduce using rule 57 (elseiforelse -> else .)
    RCRLBRACKET     reduce using rule 57 (elseiforelse -> else .)
    RETURN          reduce using rule 57 (elseiforelse -> else .)


state 201

    (60) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (69) expression -> . INT
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . opera
    (73) expression -> . ID
    (74) expression -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 206
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 202

    (62) else -> ELSE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 207


state 203

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 208


state 204

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)


state 205

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)


state 206

    (60) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT
    (68) compare -> . DIF

    EQEQ            shift and go to state 120
    LTE             shift and go to state 121
    GTE             shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    DIF             shift and go to state 125

    compare                        shift and go to state 209

state 207

    (62) else -> ELSE LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 210
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 208

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)


state 209

    (60) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (69) expression -> . INT
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . opera
    (73) expression -> . ID
    (74) expression -> . negative
    (77) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (87) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 211
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 210

    (62) else -> ELSE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 212


state 211

    (60) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 213


state 212

    (62) else -> ELSE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)


state 213

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (75) let -> . LET ID ASSIGN operand SEMICOLON
    (76) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (91) break -> . BREAK
    (92) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 92 (empty -> .)

    line                           shift and go to state 214
    empty                          shift and go to state 58
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57

state 214

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 215


state 215

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (92) empty -> .
    (56) elseiforelse -> . elseif
    (57) elseiforelse -> . else
    (60) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (62) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 92 (empty -> .)
    FN              reduce using rule 92 (empty -> .)
    FOR             reduce using rule 92 (empty -> .)
    WHILE           reduce using rule 92 (empty -> .)
    IF              reduce using rule 92 (empty -> .)
    LET             reduce using rule 92 (empty -> .)
    MOVE            reduce using rule 92 (empty -> .)
    DELAY           reduce using rule 92 (empty -> .)
    PRINT           reduce using rule 92 (empty -> .)
    BREAK           reduce using rule 92 (empty -> .)
    RCRLBRACKET     reduce using rule 92 (empty -> .)
    RETURN          reduce using rule 92 (empty -> .)
    ELSEIF          shift and go to state 201
    ELSE            shift and go to state 202

    empty                          shift and go to state 216
    elseiforelse                   shift and go to state 217
    elseif                         shift and go to state 199
    else                           shift and go to state 200

state 216

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 217

    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 24 resolved using rule (operand -> ID)
WARNING: rejected rule (bool -> ID) in state 24
WARNING: reduce/reduce conflict in state 109 resolved using rule (params -> empty empty)
WARNING: rejected rule (arg -> empty empty) in state 109
