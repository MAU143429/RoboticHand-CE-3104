Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    BREAK
    COMMA
    DIVIDE
    DOTDOT
    ELSE
    ELSEIF
    EQEQ
    FN
    FOR
    GT
    GTE
    IF
    INTEGER
    LCRLBRACKET
    LOOP
    LPAREN
    LSQRBRACKET
    LT
    LTE
    MAIN
    MINUS
    MOVE
    OPERA
    PLUS
    PRINT
    QUOT
    RANGE
    RCRLBRACKET
    RETURN
    RPAREN
    RSQRBRACKET
    TIMES
    WHILE
    WRONG_ID

Grammar

Rule 0     S' -> line
Rule 1     line -> variable
Rule 2     line -> delay
Rule 3     line -> empty
Rule 4     variable -> LET ID ASSIGN expression SEMICOLON line
Rule 5     expression -> INT
Rule 6     expression -> TRUE
Rule 7     expression -> FALSE
Rule 8     expression -> ID
Rule 9     delay -> DELAY line
Rule 10    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 
ASSIGN               : 4
BREAK                : 
COMMA                : 
DELAY                : 9
DIVIDE               : 
DOTDOT               : 
ELSE                 : 
ELSEIF               : 
EQEQ                 : 
FALSE                : 7
FN                   : 
FOR                  : 
GT                   : 
GTE                  : 
ID                   : 4 8
IF                   : 
INT                  : 5
INTEGER              : 
LCRLBRACKET          : 
LET                  : 4
LOOP                 : 
LPAREN               : 
LSQRBRACKET          : 
LT                   : 
LTE                  : 
MAIN                 : 
MINUS                : 
MOVE                 : 
OPERA                : 
PLUS                 : 
PRINT                : 
QUOT                 : 
RANGE                : 
RCRLBRACKET          : 
RETURN               : 
RPAREN               : 
RSQRBRACKET          : 
SEMICOLON            : 4
TIMES                : 
TRUE                 : 6
WHILE                : 
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

delay                : 2
empty                : 3
expression           : 4
line                 : 4 9 0
variable             : 1

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . variable
    (2) line -> . delay
    (3) line -> . empty
    (4) variable -> . LET ID ASSIGN expression SEMICOLON line
    (9) delay -> . DELAY line
    (10) empty -> .

    LET             shift and go to state 5
    DELAY           shift and go to state 6
    $end            reduce using rule 10 (empty -> .)

    line                           shift and go to state 1
    variable                       shift and go to state 2
    delay                          shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> line .



state 2

    (1) line -> variable .

    $end            reduce using rule 1 (line -> variable .)


state 3

    (2) line -> delay .

    $end            reduce using rule 2 (line -> delay .)


state 4

    (3) line -> empty .

    $end            reduce using rule 3 (line -> empty .)


state 5

    (4) variable -> LET . ID ASSIGN expression SEMICOLON line

    ID              shift and go to state 7


state 6

    (9) delay -> DELAY . line
    (1) line -> . variable
    (2) line -> . delay
    (3) line -> . empty
    (4) variable -> . LET ID ASSIGN expression SEMICOLON line
    (9) delay -> . DELAY line
    (10) empty -> .

    LET             shift and go to state 5
    DELAY           shift and go to state 6
    $end            reduce using rule 10 (empty -> .)

    line                           shift and go to state 8
    variable                       shift and go to state 2
    delay                          shift and go to state 3
    empty                          shift and go to state 4

state 7

    (4) variable -> LET ID . ASSIGN expression SEMICOLON line

    ASSIGN          shift and go to state 9


state 8

    (9) delay -> DELAY line .

    $end            reduce using rule 9 (delay -> DELAY line .)


state 9

    (4) variable -> LET ID ASSIGN . expression SEMICOLON line
    (5) expression -> . INT
    (6) expression -> . TRUE
    (7) expression -> . FALSE
    (8) expression -> . ID

    INT             shift and go to state 12
    TRUE            shift and go to state 13
    FALSE           shift and go to state 14
    ID              shift and go to state 10

    expression                     shift and go to state 11

state 10

    (8) expression -> ID .

    SEMICOLON       reduce using rule 8 (expression -> ID .)


state 11

    (4) variable -> LET ID ASSIGN expression . SEMICOLON line

    SEMICOLON       shift and go to state 15


state 12

    (5) expression -> INT .

    SEMICOLON       reduce using rule 5 (expression -> INT .)


state 13

    (6) expression -> TRUE .

    SEMICOLON       reduce using rule 6 (expression -> TRUE .)


state 14

    (7) expression -> FALSE .

    SEMICOLON       reduce using rule 7 (expression -> FALSE .)


state 15

    (4) variable -> LET ID ASSIGN expression SEMICOLON . line
    (1) line -> . variable
    (2) line -> . delay
    (3) line -> . empty
    (4) variable -> . LET ID ASSIGN expression SEMICOLON line
    (9) delay -> . DELAY line
    (10) empty -> .

    LET             shift and go to state 5
    DELAY           shift and go to state 6
    $end            reduce using rule 10 (empty -> .)

    line                           shift and go to state 16
    variable                       shift and go to state 2
    delay                          shift and go to state 3
    empty                          shift and go to state 4

state 16

    (4) variable -> LET ID ASSIGN expression SEMICOLON line .

    $end            reduce using rule 4 (variable -> LET ID ASSIGN expression SEMICOLON line .)

