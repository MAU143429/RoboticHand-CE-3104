Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    RANGE
    WRONG_ID

Grammar

Rule 0     S' -> root
Rule 1     root -> main root
Rule 2     root -> function root
Rule 3     root -> procedure root
Rule 4     root -> let root
Rule 5     root -> empty
Rule 6     functions -> ID
Rule 7     main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
Rule 8     line -> loop line
Rule 9     line -> function line
Rule 10    line -> procedure line
Rule 11    line -> for line
Rule 12    line -> while line
Rule 13    line -> if line
Rule 14    line -> let line
Rule 15    line -> move line
Rule 16    line -> moveList line
Rule 17    line -> delay line
Rule 18    line -> println line
Rule 19    line -> break line
Rule 20    line -> empty
Rule 21    procedure -> FN ID LPAREN params RPAREN prodbody
Rule 22    prodbody -> LCRLBRACKET line RCRLBRACKET
Rule 23    function -> FN ID LPAREN params RPAREN funbody
Rule 24    params -> ID arg
Rule 25    params -> empty empty
Rule 26    arg -> COMMA params
Rule 27    arg -> COMMA arg
Rule 28    arg -> empty empty
Rule 29    funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET
Rule 30    output -> INTEGER
Rule 31    output -> BOOLEAN
Rule 32    end -> RETURN expression SEMICOLON
Rule 33    loop -> LOOP LCRLBRACKET line RCRLBRACKET
Rule 34    for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
Rule 35    while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
Rule 36    while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET
Rule 37    move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
Rule 38    moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
Rule 39    fingerList -> STRING COMMA STRING
Rule 40    fingerList -> STRING COMMA fingerList
Rule 41    delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
Rule 42    unit -> QUOT MIN QUOT
Rule 43    unit -> QUOT MIL QUOT
Rule 44    unit -> QUOT SEG QUOT
Rule 45    println -> PRINT EXPR LPAREN args RPAREN SEMICOLON
Rule 46    args -> INT body
Rule 47    args -> ID body
Rule 48    args -> opera body
Rule 49    args -> TRUE body
Rule 50    args -> FALSE body
Rule 51    args -> STRING body
Rule 52    body -> COMMA args
Rule 53    body -> COMMA body
Rule 54    body -> empty empty
Rule 55    text -> QUOT ID QUOT
Rule 56    elseiforelse -> elseif
Rule 57    elseiforelse -> else
Rule 58    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 59    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 60    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 61    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 62    else -> ELSE LCRLBRACKET line RCRLBRACKET
Rule 63    compare -> EQEQ
Rule 64    compare -> LTE
Rule 65    compare -> GTE
Rule 66    compare -> LT
Rule 67    compare -> GT
Rule 68    expression -> INT
Rule 69    expression -> TRUE
Rule 70    expression -> FALSE
Rule 71    expression -> opera
Rule 72    expression -> ID
Rule 73    expression -> negative
Rule 74    let -> LET ID ASSIGN operand SEMICOLON
Rule 75    let -> LET ID ASSIGN bool SEMICOLON
Rule 76    opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN
Rule 77    operator -> PLUS
Rule 78    operator -> MINUS
Rule 79    operator -> DIVIDE
Rule 80    operator -> ASTR
Rule 81    operator -> TIMES
Rule 82    operand -> INT
Rule 83    operand -> opera
Rule 84    operand -> ID
Rule 85    operand -> negative
Rule 86    negative -> MINUS INT
Rule 87    bool -> TRUE
Rule 88    bool -> FALSE
Rule 89    bool -> ID
Rule 90    break -> BREAK
Rule 91    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 29
ASSIGN               : 74 75
ASTR                 : 80
BOOLEAN              : 31
BREAK                : 90
COMMA                : 26 27 37 38 39 40 41 52 53 76 76
DELAY                : 41
DIVIDE               : 79
DOTDOT               : 34
ELSE                 : 62
ELSEIF               : 60 61
EQEQ                 : 63
EXPR                 : 45
FALSE                : 50 70 88
FN                   : 7 21 23
FOR                  : 34
GT                   : 67
GTE                  : 65
ID                   : 6 21 23 24 34 47 55 72 74 75 84 89
IF                   : 58 59
IN                   : 34
INT                  : 34 34 41 46 68 82 86
INTEGER              : 30
LCRLBRACKET          : 7 22 29 33 34 35 36 58 59 60 61 62
LET                  : 74 75
LOOP                 : 33
LPAREN               : 7 21 23 35 37 38 41 45 76
LSQRBRACKET          : 38
LT                   : 66
LTE                  : 64
MAIN                 : 7
MIL                  : 43
MIN                  : 42
MINUS                : 78 86
MOVE                 : 37 38
OPERA                : 76
PLUS                 : 77
PRINT                : 45
QUOT                 : 42 42 43 43 44 44 55 55
RANGE                : 
RCRLBRACKET          : 7 22 29 33 34 35 36 58 59 60 61 62
RETURN               : 32
RPAREN               : 7 21 23 35 37 38 41 45 76
RSQRBRACKET          : 38
SEG                  : 44
SEMICOLON            : 32 37 38 41 45 74 75
STRING               : 37 39 39 40 41 51
TIMES                : 81
TRUE                 : 36 49 69 87
WHILE                : 35 36
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

arg                  : 24 27
args                 : 45 52
body                 : 46 47 48 49 50 51 53
bool                 : 37 38 75
break                : 19
compare              : 35 58 59 60 61
delay                : 17
else                 : 57
elseif               : 56
elseiforelse         : 59 61
empty                : 5 20 25 25 28 28 54 54 58 60
end                  : 29
expression           : 32 35 35 58 58 59 59 60 60 61 61
fingerList           : 38 40
for                  : 11
funbody              : 23
function             : 2 9
functions            : 
if                   : 13
let                  : 4 14
line                 : 7 8 9 10 11 12 13 14 15 16 17 18 19 22 29 33 34 35 36 58 59 60 61 62
loop                 : 8
main                 : 1
move                 : 15
moveList             : 16
negative             : 73 85
opera                : 48 71 83
operand              : 74 76 76
operator             : 76
output               : 29
params               : 21 23 26
println              : 18
procedure            : 3 10
prodbody             : 21
root                 : 1 2 3 4 0
text                 : 
unit                 : 
while                : 12

Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    root                           shift and go to state 1
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 1

    (0) S' -> root .



state 2

    (1) root -> main . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    main                           shift and go to state 2
    root                           shift and go to state 9
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) root -> function . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    function                       shift and go to state 3
    root                           shift and go to state 10
    main                           shift and go to state 2
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 4

    (3) root -> procedure . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    procedure                      shift and go to state 4
    root                           shift and go to state 11
    main                           shift and go to state 2
    function                       shift and go to state 3
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 5

    (4) root -> let . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    let                            shift and go to state 5
    root                           shift and go to state 12
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    empty                          shift and go to state 6

state 6

    (5) root -> empty .

    $end            reduce using rule 5 (root -> empty .)


state 7

    (7) main -> FN . MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> FN . ID LPAREN params RPAREN funbody
    (21) procedure -> FN . ID LPAREN params RPAREN prodbody

    MAIN            shift and go to state 13
    ID              shift and go to state 14


state 8

    (74) let -> LET . ID ASSIGN operand SEMICOLON
    (75) let -> LET . ID ASSIGN bool SEMICOLON

    ID              shift and go to state 15


state 9

    (1) root -> main root .

    $end            reduce using rule 1 (root -> main root .)


state 10

    (2) root -> function root .

    $end            reduce using rule 2 (root -> function root .)


state 11

    (3) root -> procedure root .

    $end            reduce using rule 3 (root -> procedure root .)


state 12

    (4) root -> let root .

    $end            reduce using rule 4 (root -> let root .)


state 13

    (7) main -> FN MAIN . LPAREN RPAREN LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 16


state 14

    (23) function -> FN ID . LPAREN params RPAREN funbody
    (21) procedure -> FN ID . LPAREN params RPAREN prodbody

    LPAREN          shift and go to state 17


state 15

    (74) let -> LET ID . ASSIGN operand SEMICOLON
    (75) let -> LET ID . ASSIGN bool SEMICOLON

    ASSIGN          shift and go to state 18


state 16

    (7) main -> FN MAIN LPAREN . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 19


state 17

    (23) function -> FN ID LPAREN . params RPAREN funbody
    (21) procedure -> FN ID LPAREN . params RPAREN prodbody
    (24) params -> . ID arg
    (25) params -> . empty empty
    (91) empty -> .

    ID              shift and go to state 20
    RPAREN          reduce using rule 91 (empty -> .)

    params                         shift and go to state 21
    empty                          shift and go to state 22

state 18

    (74) let -> LET ID ASSIGN . operand SEMICOLON
    (75) let -> LET ID ASSIGN . bool SEMICOLON
    (82) operand -> . INT
    (83) operand -> . opera
    (84) operand -> . ID
    (85) operand -> . negative
    (87) bool -> . TRUE
    (88) bool -> . FALSE
    (89) bool -> . ID
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 26
    ID              shift and go to state 23
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    operand                        shift and go to state 24
    bool                           shift and go to state 25
    opera                          shift and go to state 27
    negative                       shift and go to state 28

state 19

    (7) main -> FN MAIN LPAREN RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 33


state 20

    (24) params -> ID . arg
    (26) arg -> . COMMA params
    (27) arg -> . COMMA arg
    (28) arg -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 35
    RPAREN          reduce using rule 91 (empty -> .)

    arg                            shift and go to state 34
    empty                          shift and go to state 36

state 21

    (23) function -> FN ID LPAREN params . RPAREN funbody
    (21) procedure -> FN ID LPAREN params . RPAREN prodbody

    RPAREN          shift and go to state 37


state 22

    (25) params -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 38

state 23

    (84) operand -> ID .
    (89) bool -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 84 (operand -> ID .)
    SEMICOLON       reduce using rule 84 (operand -> ID .)

  ! SEMICOLON       [ reduce using rule 89 (bool -> ID .) ]


state 24

    (74) let -> LET ID ASSIGN operand . SEMICOLON

    SEMICOLON       shift and go to state 39


state 25

    (75) let -> LET ID ASSIGN bool . SEMICOLON

    SEMICOLON       shift and go to state 40


state 26

    (82) operand -> INT .

    SEMICOLON       reduce using rule 82 (operand -> INT .)
    COMMA           reduce using rule 82 (operand -> INT .)
    RPAREN          reduce using rule 82 (operand -> INT .)


state 27

    (83) operand -> opera .

    SEMICOLON       reduce using rule 83 (operand -> opera .)
    COMMA           reduce using rule 83 (operand -> opera .)
    RPAREN          reduce using rule 83 (operand -> opera .)


state 28

    (85) operand -> negative .

    SEMICOLON       reduce using rule 85 (operand -> negative .)
    COMMA           reduce using rule 85 (operand -> negative .)
    RPAREN          reduce using rule 85 (operand -> negative .)


state 29

    (87) bool -> TRUE .

    SEMICOLON       reduce using rule 87 (bool -> TRUE .)
    RPAREN          reduce using rule 87 (bool -> TRUE .)


state 30

    (88) bool -> FALSE .

    SEMICOLON       reduce using rule 88 (bool -> FALSE .)
    RPAREN          reduce using rule 88 (bool -> FALSE .)


state 31

    (76) opera -> OPERA . LPAREN operator COMMA operand COMMA operand RPAREN

    LPAREN          shift and go to state 41


state 32

    (86) negative -> MINUS . INT

    INT             shift and go to state 42


state 33

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 44
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 34

    (24) params -> ID arg .

    RPAREN          reduce using rule 24 (params -> ID arg .)


state 35

    (26) arg -> COMMA . params
    (27) arg -> COMMA . arg
    (24) params -> . ID arg
    (25) params -> . empty empty
    (26) arg -> . COMMA params
    (27) arg -> . COMMA arg
    (28) arg -> . empty empty
    (91) empty -> .

    ID              shift and go to state 20
    COMMA           shift and go to state 35
    RPAREN          reduce using rule 91 (empty -> .)

    params                         shift and go to state 66
    arg                            shift and go to state 67
    empty                          shift and go to state 68

state 36

    (28) arg -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 69

state 37

    (23) function -> FN ID LPAREN params RPAREN . funbody
    (21) procedure -> FN ID LPAREN params RPAREN . prodbody
    (29) funbody -> . ARROW output LCRLBRACKET line end RCRLBRACKET
    (22) prodbody -> . LCRLBRACKET line RCRLBRACKET

    ARROW           shift and go to state 72
    LCRLBRACKET     shift and go to state 73

    funbody                        shift and go to state 70
    prodbody                       shift and go to state 71

state 38

    (25) params -> empty empty .

    RPAREN          reduce using rule 25 (params -> empty empty .)


state 39

    (74) let -> LET ID ASSIGN operand SEMICOLON .

    FN              reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    LET             reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    $end            reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    LOOP            reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    FOR             reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    WHILE           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    IF              reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    MOVE            reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    DELAY           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    PRINT           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    BREAK           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    RCRLBRACKET     reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    RETURN          reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)


state 40

    (75) let -> LET ID ASSIGN bool SEMICOLON .

    FN              reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    LET             reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    $end            reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    LOOP            reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    FOR             reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    WHILE           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    IF              reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    MOVE            reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    DELAY           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    PRINT           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    BREAK           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    RCRLBRACKET     reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    RETURN          reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)


state 41

    (76) opera -> OPERA LPAREN . operator COMMA operand COMMA operand RPAREN
    (77) operator -> . PLUS
    (78) operator -> . MINUS
    (79) operator -> . DIVIDE
    (80) operator -> . ASTR
    (81) operator -> . TIMES

    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    DIVIDE          shift and go to state 77
    ASTR            shift and go to state 78
    TIMES           shift and go to state 79

    operator                       shift and go to state 74

state 42

    (86) negative -> MINUS INT .

    SEMICOLON       reduce using rule 86 (negative -> MINUS INT .)
    EQEQ            reduce using rule 86 (negative -> MINUS INT .)
    LTE             reduce using rule 86 (negative -> MINUS INT .)
    GTE             reduce using rule 86 (negative -> MINUS INT .)
    LT              reduce using rule 86 (negative -> MINUS INT .)
    GT              reduce using rule 86 (negative -> MINUS INT .)
    COMMA           reduce using rule 86 (negative -> MINUS INT .)
    LCRLBRACKET     reduce using rule 86 (negative -> MINUS INT .)
    RPAREN          reduce using rule 86 (negative -> MINUS INT .)


state 43

    (23) function -> FN . ID LPAREN params RPAREN funbody
    (21) procedure -> FN . ID LPAREN params RPAREN prodbody

    ID              shift and go to state 14


state 44

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 80


state 45

    (8) line -> loop . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    loop                           shift and go to state 45
    line                           shift and go to state 81
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 46

    (9) line -> function . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    function                       shift and go to state 46
    line                           shift and go to state 82
    loop                           shift and go to state 45
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 47

    (10) line -> procedure . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    procedure                      shift and go to state 47
    line                           shift and go to state 83
    loop                           shift and go to state 45
    function                       shift and go to state 46
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 48

    (11) line -> for . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    for                            shift and go to state 48
    line                           shift and go to state 84
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 49

    (12) line -> while . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    while                          shift and go to state 49
    line                           shift and go to state 85
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 50

    (13) line -> if . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    if                             shift and go to state 50
    line                           shift and go to state 86
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 51

    (14) line -> let . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    let                            shift and go to state 51
    line                           shift and go to state 87
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 52

    (15) line -> move . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    move                           shift and go to state 52
    line                           shift and go to state 88
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 53

    (16) line -> moveList . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    moveList                       shift and go to state 53
    line                           shift and go to state 89
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 54

    (17) line -> delay . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    delay                          shift and go to state 54
    line                           shift and go to state 90
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 55

    (18) line -> println . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    println                        shift and go to state 55
    line                           shift and go to state 91
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 56

    (19) line -> break . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    break                          shift and go to state 56
    line                           shift and go to state 92
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    empty                          shift and go to state 57

state 57

    (20) line -> empty .

    RCRLBRACKET     reduce using rule 20 (line -> empty .)
    RETURN          reduce using rule 20 (line -> empty .)


state 58

    (33) loop -> LOOP . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 93


state 59

    (34) for -> FOR . ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    ID              shift and go to state 94


state 60

    (35) while -> WHILE . LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> WHILE . TRUE LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 95
    TRUE            shift and go to state 96


state 61

    (58) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 98
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100
    ID              shift and go to state 102
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    expression                     shift and go to state 97
    opera                          shift and go to state 101
    negative                       shift and go to state 103

state 62

    (37) move -> MOVE . LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> MOVE . LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    LPAREN          shift and go to state 104


state 63

    (41) delay -> DELAY . LPAREN INT COMMA STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 105


state 64

    (45) println -> PRINT . EXPR LPAREN args RPAREN SEMICOLON

    EXPR            shift and go to state 106


state 65

    (90) break -> BREAK .

    LOOP            reduce using rule 90 (break -> BREAK .)
    FN              reduce using rule 90 (break -> BREAK .)
    FOR             reduce using rule 90 (break -> BREAK .)
    WHILE           reduce using rule 90 (break -> BREAK .)
    IF              reduce using rule 90 (break -> BREAK .)
    LET             reduce using rule 90 (break -> BREAK .)
    MOVE            reduce using rule 90 (break -> BREAK .)
    DELAY           reduce using rule 90 (break -> BREAK .)
    PRINT           reduce using rule 90 (break -> BREAK .)
    BREAK           reduce using rule 90 (break -> BREAK .)
    RCRLBRACKET     reduce using rule 90 (break -> BREAK .)
    RETURN          reduce using rule 90 (break -> BREAK .)


state 66

    (26) arg -> COMMA params .

    RPAREN          reduce using rule 26 (arg -> COMMA params .)


state 67

    (27) arg -> COMMA arg .

    RPAREN          reduce using rule 27 (arg -> COMMA arg .)


state 68

    (25) params -> empty . empty
    (28) arg -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 107

state 69

    (28) arg -> empty empty .

    RPAREN          reduce using rule 28 (arg -> empty empty .)


state 70

    (23) function -> FN ID LPAREN params RPAREN funbody .

    FN              reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    LET             reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    $end            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    LOOP            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    FOR             reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    WHILE           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    IF              reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    MOVE            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    DELAY           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    PRINT           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    BREAK           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    RCRLBRACKET     reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    RETURN          reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)


state 71

    (21) procedure -> FN ID LPAREN params RPAREN prodbody .

    FN              reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LET             reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    $end            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LOOP            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    FOR             reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    WHILE           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    IF              reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    MOVE            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    DELAY           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    PRINT           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    BREAK           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RCRLBRACKET     reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RETURN          reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)


state 72

    (29) funbody -> ARROW . output LCRLBRACKET line end RCRLBRACKET
    (30) output -> . INTEGER
    (31) output -> . BOOLEAN

    INTEGER         shift and go to state 109
    BOOLEAN         shift and go to state 110

    output                         shift and go to state 108

state 73

    (22) prodbody -> LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 111
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 74

    (76) opera -> OPERA LPAREN operator . COMMA operand COMMA operand RPAREN

    COMMA           shift and go to state 112


state 75

    (77) operator -> PLUS .

    COMMA           reduce using rule 77 (operator -> PLUS .)


state 76

    (78) operator -> MINUS .

    COMMA           reduce using rule 78 (operator -> MINUS .)


state 77

    (79) operator -> DIVIDE .

    COMMA           reduce using rule 79 (operator -> DIVIDE .)


state 78

    (80) operator -> ASTR .

    COMMA           reduce using rule 80 (operator -> ASTR .)


state 79

    (81) operator -> TIMES .

    COMMA           reduce using rule 81 (operator -> TIMES .)


state 80

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)


state 81

    (8) line -> loop line .

    RCRLBRACKET     reduce using rule 8 (line -> loop line .)
    RETURN          reduce using rule 8 (line -> loop line .)


state 82

    (9) line -> function line .

    RCRLBRACKET     reduce using rule 9 (line -> function line .)
    RETURN          reduce using rule 9 (line -> function line .)


state 83

    (10) line -> procedure line .

    RCRLBRACKET     reduce using rule 10 (line -> procedure line .)
    RETURN          reduce using rule 10 (line -> procedure line .)


state 84

    (11) line -> for line .

    RCRLBRACKET     reduce using rule 11 (line -> for line .)
    RETURN          reduce using rule 11 (line -> for line .)


state 85

    (12) line -> while line .

    RCRLBRACKET     reduce using rule 12 (line -> while line .)
    RETURN          reduce using rule 12 (line -> while line .)


state 86

    (13) line -> if line .

    RCRLBRACKET     reduce using rule 13 (line -> if line .)
    RETURN          reduce using rule 13 (line -> if line .)


state 87

    (14) line -> let line .

    RCRLBRACKET     reduce using rule 14 (line -> let line .)
    RETURN          reduce using rule 14 (line -> let line .)


state 88

    (15) line -> move line .

    RCRLBRACKET     reduce using rule 15 (line -> move line .)
    RETURN          reduce using rule 15 (line -> move line .)


state 89

    (16) line -> moveList line .

    RCRLBRACKET     reduce using rule 16 (line -> moveList line .)
    RETURN          reduce using rule 16 (line -> moveList line .)


state 90

    (17) line -> delay line .

    RCRLBRACKET     reduce using rule 17 (line -> delay line .)
    RETURN          reduce using rule 17 (line -> delay line .)


state 91

    (18) line -> println line .

    RCRLBRACKET     reduce using rule 18 (line -> println line .)
    RETURN          reduce using rule 18 (line -> println line .)


state 92

    (19) line -> break line .

    RCRLBRACKET     reduce using rule 19 (line -> break line .)
    RETURN          reduce using rule 19 (line -> break line .)


state 93

    (33) loop -> LOOP LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 113
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 94

    (34) for -> FOR ID . IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    IN              shift and go to state 114


state 95

    (35) while -> WHILE LPAREN . expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 98
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100
    ID              shift and go to state 102
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    expression                     shift and go to state 115
    opera                          shift and go to state 101
    negative                       shift and go to state 103

state 96

    (36) while -> WHILE TRUE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 116


state 97

    (58) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT

    EQEQ            shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    GT              shift and go to state 122

    compare                        shift and go to state 117

state 98

    (68) expression -> INT .

    EQEQ            reduce using rule 68 (expression -> INT .)
    LTE             reduce using rule 68 (expression -> INT .)
    GTE             reduce using rule 68 (expression -> INT .)
    LT              reduce using rule 68 (expression -> INT .)
    GT              reduce using rule 68 (expression -> INT .)
    LCRLBRACKET     reduce using rule 68 (expression -> INT .)
    RPAREN          reduce using rule 68 (expression -> INT .)
    SEMICOLON       reduce using rule 68 (expression -> INT .)


state 99

    (69) expression -> TRUE .

    EQEQ            reduce using rule 69 (expression -> TRUE .)
    LTE             reduce using rule 69 (expression -> TRUE .)
    GTE             reduce using rule 69 (expression -> TRUE .)
    LT              reduce using rule 69 (expression -> TRUE .)
    GT              reduce using rule 69 (expression -> TRUE .)
    LCRLBRACKET     reduce using rule 69 (expression -> TRUE .)
    RPAREN          reduce using rule 69 (expression -> TRUE .)
    SEMICOLON       reduce using rule 69 (expression -> TRUE .)


state 100

    (70) expression -> FALSE .

    EQEQ            reduce using rule 70 (expression -> FALSE .)
    LTE             reduce using rule 70 (expression -> FALSE .)
    GTE             reduce using rule 70 (expression -> FALSE .)
    LT              reduce using rule 70 (expression -> FALSE .)
    GT              reduce using rule 70 (expression -> FALSE .)
    LCRLBRACKET     reduce using rule 70 (expression -> FALSE .)
    RPAREN          reduce using rule 70 (expression -> FALSE .)
    SEMICOLON       reduce using rule 70 (expression -> FALSE .)


state 101

    (71) expression -> opera .

    EQEQ            reduce using rule 71 (expression -> opera .)
    LTE             reduce using rule 71 (expression -> opera .)
    GTE             reduce using rule 71 (expression -> opera .)
    LT              reduce using rule 71 (expression -> opera .)
    GT              reduce using rule 71 (expression -> opera .)
    LCRLBRACKET     reduce using rule 71 (expression -> opera .)
    RPAREN          reduce using rule 71 (expression -> opera .)
    SEMICOLON       reduce using rule 71 (expression -> opera .)


state 102

    (72) expression -> ID .

    EQEQ            reduce using rule 72 (expression -> ID .)
    LTE             reduce using rule 72 (expression -> ID .)
    GTE             reduce using rule 72 (expression -> ID .)
    LT              reduce using rule 72 (expression -> ID .)
    GT              reduce using rule 72 (expression -> ID .)
    LCRLBRACKET     reduce using rule 72 (expression -> ID .)
    RPAREN          reduce using rule 72 (expression -> ID .)
    SEMICOLON       reduce using rule 72 (expression -> ID .)


state 103

    (73) expression -> negative .

    EQEQ            reduce using rule 73 (expression -> negative .)
    LTE             reduce using rule 73 (expression -> negative .)
    GTE             reduce using rule 73 (expression -> negative .)
    LT              reduce using rule 73 (expression -> negative .)
    GT              reduce using rule 73 (expression -> negative .)
    LCRLBRACKET     reduce using rule 73 (expression -> negative .)
    RPAREN          reduce using rule 73 (expression -> negative .)
    SEMICOLON       reduce using rule 73 (expression -> negative .)


state 104

    (37) move -> MOVE LPAREN . STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> MOVE LPAREN . LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    STRING          shift and go to state 123
    LSQRBRACKET     shift and go to state 124


state 105

    (41) delay -> DELAY LPAREN . INT COMMA STRING RPAREN SEMICOLON

    INT             shift and go to state 125


state 106

    (45) println -> PRINT EXPR . LPAREN args RPAREN SEMICOLON

    LPAREN          shift and go to state 126


state 107

    (25) params -> empty empty .
    (28) arg -> empty empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 25 (params -> empty empty .)
    RPAREN          reduce using rule 25 (params -> empty empty .)

  ! RPAREN          [ reduce using rule 28 (arg -> empty empty .) ]


state 108

    (29) funbody -> ARROW output . LCRLBRACKET line end RCRLBRACKET

    LCRLBRACKET     shift and go to state 127


state 109

    (30) output -> INTEGER .

    LCRLBRACKET     reduce using rule 30 (output -> INTEGER .)


state 110

    (31) output -> BOOLEAN .

    LCRLBRACKET     reduce using rule 31 (output -> BOOLEAN .)


state 111

    (22) prodbody -> LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 128


state 112

    (76) opera -> OPERA LPAREN operator COMMA . operand COMMA operand RPAREN
    (82) operand -> . INT
    (83) operand -> . opera
    (84) operand -> . ID
    (85) operand -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 26
    ID              shift and go to state 130
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    operand                        shift and go to state 129
    opera                          shift and go to state 27
    negative                       shift and go to state 28

state 113

    (33) loop -> LOOP LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 131


state 114

    (34) for -> FOR ID IN . INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 132


state 115

    (35) while -> WHILE LPAREN expression . compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT

    EQEQ            shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    GT              shift and go to state 122

    compare                        shift and go to state 133

state 116

    (36) while -> WHILE TRUE LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 134
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 117

    (58) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 98
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100
    ID              shift and go to state 102
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    expression                     shift and go to state 135
    opera                          shift and go to state 101
    negative                       shift and go to state 103

state 118

    (63) compare -> EQEQ .

    INT             reduce using rule 63 (compare -> EQEQ .)
    TRUE            reduce using rule 63 (compare -> EQEQ .)
    FALSE           reduce using rule 63 (compare -> EQEQ .)
    ID              reduce using rule 63 (compare -> EQEQ .)
    OPERA           reduce using rule 63 (compare -> EQEQ .)
    MINUS           reduce using rule 63 (compare -> EQEQ .)


state 119

    (64) compare -> LTE .

    INT             reduce using rule 64 (compare -> LTE .)
    TRUE            reduce using rule 64 (compare -> LTE .)
    FALSE           reduce using rule 64 (compare -> LTE .)
    ID              reduce using rule 64 (compare -> LTE .)
    OPERA           reduce using rule 64 (compare -> LTE .)
    MINUS           reduce using rule 64 (compare -> LTE .)


state 120

    (65) compare -> GTE .

    INT             reduce using rule 65 (compare -> GTE .)
    TRUE            reduce using rule 65 (compare -> GTE .)
    FALSE           reduce using rule 65 (compare -> GTE .)
    ID              reduce using rule 65 (compare -> GTE .)
    OPERA           reduce using rule 65 (compare -> GTE .)
    MINUS           reduce using rule 65 (compare -> GTE .)


state 121

    (66) compare -> LT .

    INT             reduce using rule 66 (compare -> LT .)
    TRUE            reduce using rule 66 (compare -> LT .)
    FALSE           reduce using rule 66 (compare -> LT .)
    ID              reduce using rule 66 (compare -> LT .)
    OPERA           reduce using rule 66 (compare -> LT .)
    MINUS           reduce using rule 66 (compare -> LT .)


state 122

    (67) compare -> GT .

    INT             reduce using rule 67 (compare -> GT .)
    TRUE            reduce using rule 67 (compare -> GT .)
    FALSE           reduce using rule 67 (compare -> GT .)
    ID              reduce using rule 67 (compare -> GT .)
    OPERA           reduce using rule 67 (compare -> GT .)
    MINUS           reduce using rule 67 (compare -> GT .)


state 123

    (37) move -> MOVE LPAREN STRING . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 136


state 124

    (38) moveList -> MOVE LPAREN LSQRBRACKET . fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (39) fingerList -> . STRING COMMA STRING
    (40) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 138

    fingerList                     shift and go to state 137

state 125

    (41) delay -> DELAY LPAREN INT . COMMA STRING RPAREN SEMICOLON

    COMMA           shift and go to state 139


state 126

    (45) println -> PRINT EXPR LPAREN . args RPAREN SEMICOLON
    (46) args -> . INT body
    (47) args -> . ID body
    (48) args -> . opera body
    (49) args -> . TRUE body
    (50) args -> . FALSE body
    (51) args -> . STRING body
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 141
    ID              shift and go to state 142
    TRUE            shift and go to state 144
    FALSE           shift and go to state 145
    STRING          shift and go to state 146
    OPERA           shift and go to state 31

    args                           shift and go to state 140
    opera                          shift and go to state 143

state 127

    (29) funbody -> ARROW output LCRLBRACKET . line end RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RETURN          reduce using rule 91 (empty -> .)

    line                           shift and go to state 147
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 128

    (22) prodbody -> LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)


state 129

    (76) opera -> OPERA LPAREN operator COMMA operand . COMMA operand RPAREN

    COMMA           shift and go to state 148


state 130

    (84) operand -> ID .

    COMMA           reduce using rule 84 (operand -> ID .)
    RPAREN          reduce using rule 84 (operand -> ID .)


state 131

    (33) loop -> LOOP LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)


state 132

    (34) for -> FOR ID IN INT . DOTDOT INT LCRLBRACKET line RCRLBRACKET

    DOTDOT          shift and go to state 149


state 133

    (35) while -> WHILE LPAREN expression compare . expression RPAREN LCRLBRACKET line RCRLBRACKET
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 98
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100
    ID              shift and go to state 102
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    expression                     shift and go to state 150
    opera                          shift and go to state 101
    negative                       shift and go to state 103

state 134

    (36) while -> WHILE TRUE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 151


state 135

    (58) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 152


state 136

    (37) move -> MOVE LPAREN STRING COMMA . bool RPAREN SEMICOLON
    (87) bool -> . TRUE
    (88) bool -> . FALSE
    (89) bool -> . ID

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    ID              shift and go to state 154

    bool                           shift and go to state 153

state 137

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList . RSQRBRACKET COMMA bool RPAREN SEMICOLON

    RSQRBRACKET     shift and go to state 155


state 138

    (39) fingerList -> STRING . COMMA STRING
    (40) fingerList -> STRING . COMMA fingerList

    COMMA           shift and go to state 156


state 139

    (41) delay -> DELAY LPAREN INT COMMA . STRING RPAREN SEMICOLON

    STRING          shift and go to state 157


state 140

    (45) println -> PRINT EXPR LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 158


state 141

    (46) args -> INT . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 160
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 159
    empty                          shift and go to state 161

state 142

    (47) args -> ID . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 160
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 162
    empty                          shift and go to state 161

state 143

    (48) args -> opera . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 160
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 163
    empty                          shift and go to state 161

state 144

    (49) args -> TRUE . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 160
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 164
    empty                          shift and go to state 161

state 145

    (50) args -> FALSE . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 160
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 165
    empty                          shift and go to state 161

state 146

    (51) args -> STRING . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 160
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 166
    empty                          shift and go to state 161

state 147

    (29) funbody -> ARROW output LCRLBRACKET line . end RCRLBRACKET
    (32) end -> . RETURN expression SEMICOLON

    RETURN          shift and go to state 168

    end                            shift and go to state 167

state 148

    (76) opera -> OPERA LPAREN operator COMMA operand COMMA . operand RPAREN
    (82) operand -> . INT
    (83) operand -> . opera
    (84) operand -> . ID
    (85) operand -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 26
    ID              shift and go to state 130
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    operand                        shift and go to state 169
    opera                          shift and go to state 27
    negative                       shift and go to state 28

state 149

    (34) for -> FOR ID IN INT DOTDOT . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 170


state 150

    (35) while -> WHILE LPAREN expression compare expression . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 171


state 151

    (36) while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)


state 152

    (58) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (59) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 172
    empty                          shift and go to state 57
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56

state 153

    (37) move -> MOVE LPAREN STRING COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 173


state 154

    (89) bool -> ID .

    RPAREN          reduce using rule 89 (bool -> ID .)


state 155

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 174


state 156

    (39) fingerList -> STRING COMMA . STRING
    (40) fingerList -> STRING COMMA . fingerList
    (39) fingerList -> . STRING COMMA STRING
    (40) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 175

    fingerList                     shift and go to state 176

state 157

    (41) delay -> DELAY LPAREN INT COMMA STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 177


state 158

    (45) println -> PRINT EXPR LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 178


state 159

    (46) args -> INT body .

    RPAREN          reduce using rule 46 (args -> INT body .)


state 160

    (52) body -> COMMA . args
    (53) body -> COMMA . body
    (46) args -> . INT body
    (47) args -> . ID body
    (48) args -> . opera body
    (49) args -> . TRUE body
    (50) args -> . FALSE body
    (51) args -> . STRING body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) empty -> .

    INT             shift and go to state 141
    ID              shift and go to state 142
    TRUE            shift and go to state 144
    FALSE           shift and go to state 145
    STRING          shift and go to state 146
    COMMA           shift and go to state 160
    OPERA           shift and go to state 31
    RPAREN          reduce using rule 91 (empty -> .)

    args                           shift and go to state 179
    body                           shift and go to state 180
    opera                          shift and go to state 143
    empty                          shift and go to state 161

state 161

    (54) body -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 181

state 162

    (47) args -> ID body .

    RPAREN          reduce using rule 47 (args -> ID body .)


state 163

    (48) args -> opera body .

    RPAREN          reduce using rule 48 (args -> opera body .)


state 164

    (49) args -> TRUE body .

    RPAREN          reduce using rule 49 (args -> TRUE body .)


state 165

    (50) args -> FALSE body .

    RPAREN          reduce using rule 50 (args -> FALSE body .)


state 166

    (51) args -> STRING body .

    RPAREN          reduce using rule 51 (args -> STRING body .)


state 167

    (29) funbody -> ARROW output LCRLBRACKET line end . RCRLBRACKET

    RCRLBRACKET     shift and go to state 182


state 168

    (32) end -> RETURN . expression SEMICOLON
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 98
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100
    ID              shift and go to state 102
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    expression                     shift and go to state 183
    opera                          shift and go to state 101
    negative                       shift and go to state 103

state 169

    (76) opera -> OPERA LPAREN operator COMMA operand COMMA operand . RPAREN

    RPAREN          shift and go to state 184


state 170

    (34) for -> FOR ID IN INT DOTDOT INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 185


state 171

    (35) while -> WHILE LPAREN expression compare expression RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 186


state 172

    (58) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (59) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 187


state 173

    (37) move -> MOVE LPAREN STRING COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 188


state 174

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA . bool RPAREN SEMICOLON
    (87) bool -> . TRUE
    (88) bool -> . FALSE
    (89) bool -> . ID

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    ID              shift and go to state 154

    bool                           shift and go to state 189

state 175

    (39) fingerList -> STRING COMMA STRING .
    (39) fingerList -> STRING . COMMA STRING
    (40) fingerList -> STRING . COMMA fingerList

    RSQRBRACKET     reduce using rule 39 (fingerList -> STRING COMMA STRING .)
    COMMA           shift and go to state 156


state 176

    (40) fingerList -> STRING COMMA fingerList .

    RSQRBRACKET     reduce using rule 40 (fingerList -> STRING COMMA fingerList .)


state 177

    (41) delay -> DELAY LPAREN INT COMMA STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 190


state 178

    (45) println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .

    LOOP            reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FN              reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    LET             reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    MOVE            reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    DELAY           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    PRINT           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    BREAK           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)


state 179

    (52) body -> COMMA args .

    RPAREN          reduce using rule 52 (body -> COMMA args .)


state 180

    (53) body -> COMMA body .

    RPAREN          reduce using rule 53 (body -> COMMA body .)


state 181

    (54) body -> empty empty .

    RPAREN          reduce using rule 54 (body -> empty empty .)


state 182

    (29) funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .

    FN              reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LET             reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    $end            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LOOP            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    FOR             reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    WHILE           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    IF              reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    MOVE            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    DELAY           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    PRINT           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    BREAK           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RETURN          reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)


state 183

    (32) end -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 191


state 184

    (76) opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .

    SEMICOLON       reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    EQEQ            reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LTE             reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GTE             reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LT              reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GT              reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    COMMA           reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LCRLBRACKET     reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    RPAREN          reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)


state 185

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 192
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 186

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 193
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 187

    (58) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (59) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (91) empty -> .
    (56) elseiforelse -> . elseif
    (57) elseiforelse -> . else
    (60) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (62) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 91 (empty -> .)
    FN              reduce using rule 91 (empty -> .)
    FOR             reduce using rule 91 (empty -> .)
    WHILE           reduce using rule 91 (empty -> .)
    IF              reduce using rule 91 (empty -> .)
    LET             reduce using rule 91 (empty -> .)
    MOVE            reduce using rule 91 (empty -> .)
    DELAY           reduce using rule 91 (empty -> .)
    PRINT           reduce using rule 91 (empty -> .)
    BREAK           reduce using rule 91 (empty -> .)
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)
    ELSEIF          shift and go to state 198
    ELSE            shift and go to state 199

    empty                          shift and go to state 194
    elseiforelse                   shift and go to state 195
    elseif                         shift and go to state 196
    else                           shift and go to state 197

state 188

    (37) move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)


state 189

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 200


state 190

    (41) delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .

    LOOP            reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FN              reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    IF              reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    LET             reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    MOVE            reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    DELAY           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    BREAK           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)


state 191

    (32) end -> RETURN expression SEMICOLON .

    RCRLBRACKET     reduce using rule 32 (end -> RETURN expression SEMICOLON .)


state 192

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 201


state 193

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 202


state 194

    (58) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 195

    (59) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)


state 196

    (56) elseiforelse -> elseif .

    LOOP            reduce using rule 56 (elseiforelse -> elseif .)
    FN              reduce using rule 56 (elseiforelse -> elseif .)
    FOR             reduce using rule 56 (elseiforelse -> elseif .)
    WHILE           reduce using rule 56 (elseiforelse -> elseif .)
    IF              reduce using rule 56 (elseiforelse -> elseif .)
    LET             reduce using rule 56 (elseiforelse -> elseif .)
    MOVE            reduce using rule 56 (elseiforelse -> elseif .)
    DELAY           reduce using rule 56 (elseiforelse -> elseif .)
    PRINT           reduce using rule 56 (elseiforelse -> elseif .)
    BREAK           reduce using rule 56 (elseiforelse -> elseif .)
    RCRLBRACKET     reduce using rule 56 (elseiforelse -> elseif .)
    RETURN          reduce using rule 56 (elseiforelse -> elseif .)


state 197

    (57) elseiforelse -> else .

    LOOP            reduce using rule 57 (elseiforelse -> else .)
    FN              reduce using rule 57 (elseiforelse -> else .)
    FOR             reduce using rule 57 (elseiforelse -> else .)
    WHILE           reduce using rule 57 (elseiforelse -> else .)
    IF              reduce using rule 57 (elseiforelse -> else .)
    LET             reduce using rule 57 (elseiforelse -> else .)
    MOVE            reduce using rule 57 (elseiforelse -> else .)
    DELAY           reduce using rule 57 (elseiforelse -> else .)
    PRINT           reduce using rule 57 (elseiforelse -> else .)
    BREAK           reduce using rule 57 (elseiforelse -> else .)
    RCRLBRACKET     reduce using rule 57 (elseiforelse -> else .)
    RETURN          reduce using rule 57 (elseiforelse -> else .)


state 198

    (60) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 98
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100
    ID              shift and go to state 102
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    expression                     shift and go to state 203
    opera                          shift and go to state 101
    negative                       shift and go to state 103

state 199

    (62) else -> ELSE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 204


state 200

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 205


state 201

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)


state 202

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)


state 203

    (60) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT

    EQEQ            shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    GT              shift and go to state 122

    compare                        shift and go to state 206

state 204

    (62) else -> ELSE LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 207
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56
    empty                          shift and go to state 57

state 205

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)


state 206

    (60) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 98
    TRUE            shift and go to state 99
    FALSE           shift and go to state 100
    ID              shift and go to state 102
    OPERA           shift and go to state 31
    MINUS           shift and go to state 32

    expression                     shift and go to state 208
    opera                          shift and go to state 101
    negative                       shift and go to state 103

state 207

    (62) else -> ELSE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 209


state 208

    (60) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 210


state 209

    (62) else -> ELSE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)


state 210

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 58
    FN              shift and go to state 43
    FOR             shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61
    LET             shift and go to state 8
    MOVE            shift and go to state 62
    DELAY           shift and go to state 63
    PRINT           shift and go to state 64
    BREAK           shift and go to state 65
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 211
    empty                          shift and go to state 57
    loop                           shift and go to state 45
    function                       shift and go to state 46
    procedure                      shift and go to state 47
    for                            shift and go to state 48
    while                          shift and go to state 49
    if                             shift and go to state 50
    let                            shift and go to state 51
    move                           shift and go to state 52
    moveList                       shift and go to state 53
    delay                          shift and go to state 54
    println                        shift and go to state 55
    break                          shift and go to state 56

state 211

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 212


state 212

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (91) empty -> .
    (56) elseiforelse -> . elseif
    (57) elseiforelse -> . else
    (60) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (62) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 91 (empty -> .)
    FN              reduce using rule 91 (empty -> .)
    FOR             reduce using rule 91 (empty -> .)
    WHILE           reduce using rule 91 (empty -> .)
    IF              reduce using rule 91 (empty -> .)
    LET             reduce using rule 91 (empty -> .)
    MOVE            reduce using rule 91 (empty -> .)
    DELAY           reduce using rule 91 (empty -> .)
    PRINT           reduce using rule 91 (empty -> .)
    BREAK           reduce using rule 91 (empty -> .)
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)
    ELSEIF          shift and go to state 198
    ELSE            shift and go to state 199

    empty                          shift and go to state 213
    elseiforelse                   shift and go to state 214
    elseif                         shift and go to state 196
    else                           shift and go to state 197

state 213

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 214

    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 23 resolved using rule (operand -> ID)
WARNING: rejected rule (bool -> ID) in state 23
WARNING: reduce/reduce conflict in state 107 resolved using rule (params -> empty empty)
WARNING: rejected rule (arg -> empty empty) in state 107
