Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    RANGE
    WRONG_ID

Grammar

Rule 0     S' -> root
Rule 1     root -> main root
Rule 2     root -> function root
Rule 3     root -> procedure root
Rule 4     root -> let root
Rule 5     root -> empty empty
Rule 6     functions -> ID
Rule 7     main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
Rule 8     line -> loop line
Rule 9     line -> function line
Rule 10    line -> procedure line
Rule 11    line -> for line
Rule 12    line -> while line
Rule 13    line -> if line
Rule 14    line -> let line
Rule 15    line -> move line
Rule 16    line -> moveList line
Rule 17    line -> delay line
Rule 18    line -> println line
Rule 19    line -> break line
Rule 20    line -> empty empty
Rule 21    procedure -> FN ID LPAREN params RPAREN prodbody
Rule 22    prodbody -> LCRLBRACKET line RCRLBRACKET
Rule 23    function -> FN ID LPAREN params RPAREN funbody
Rule 24    params -> ID arg
Rule 25    params -> empty empty
Rule 26    arg -> COMMA params
Rule 27    arg -> COMMA arg
Rule 28    arg -> empty empty
Rule 29    funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET
Rule 30    output -> INTEGER
Rule 31    output -> BOOLEAN
Rule 32    end -> RETURN expression SEMICOLON
Rule 33    loop -> LOOP LCRLBRACKET line RCRLBRACKET
Rule 34    for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
Rule 35    while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
Rule 36    while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET
Rule 37    move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
Rule 38    moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
Rule 39    fingerList -> STRING COMMA STRING
Rule 40    fingerList -> STRING COMMA fingerList
Rule 41    delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
Rule 42    unit -> QUOT MIN QUOT
Rule 43    unit -> QUOT MIL QUOT
Rule 44    unit -> QUOT SEG QUOT
Rule 45    println -> PRINT EXPR LPAREN args RPAREN SEMICOLON
Rule 46    args -> INT body
Rule 47    args -> ID body
Rule 48    args -> opera body
Rule 49    args -> TRUE body
Rule 50    args -> FALSE body
Rule 51    args -> STRING body
Rule 52    body -> COMMA args
Rule 53    body -> COMMA body
Rule 54    body -> empty empty
Rule 55    text -> QUOT ID QUOT
Rule 56    elseiforelse -> elseif
Rule 57    elseiforelse -> else
Rule 58    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 59    if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 60    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
Rule 61    elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
Rule 62    else -> ELSE LCRLBRACKET line RCRLBRACKET
Rule 63    compare -> EQEQ
Rule 64    compare -> LTE
Rule 65    compare -> GTE
Rule 66    compare -> LT
Rule 67    compare -> GT
Rule 68    expression -> INT
Rule 69    expression -> TRUE
Rule 70    expression -> FALSE
Rule 71    expression -> opera
Rule 72    expression -> ID
Rule 73    expression -> negative
Rule 74    let -> LET ID ASSIGN operand SEMICOLON
Rule 75    let -> LET ID ASSIGN bool SEMICOLON
Rule 76    opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN
Rule 77    operator -> PLUS
Rule 78    operator -> MINUS
Rule 79    operator -> DIVIDE
Rule 80    operator -> ASTR
Rule 81    operator -> TIMES
Rule 82    operand -> INT
Rule 83    operand -> opera
Rule 84    operand -> ID
Rule 85    operand -> negative
Rule 86    negative -> MINUS INT
Rule 87    bool -> TRUE
Rule 88    bool -> FALSE
Rule 89    bool -> ID
Rule 90    break -> BREAK
Rule 91    empty -> <empty>

Terminals, with rules where they appear

ARROW                : 29
ASSIGN               : 74 75
ASTR                 : 80
BOOLEAN              : 31
BREAK                : 90
COMMA                : 26 27 37 38 39 40 41 52 53 76 76
DELAY                : 41
DIVIDE               : 79
DOTDOT               : 34
ELSE                 : 62
ELSEIF               : 60 61
EQEQ                 : 63
EXPR                 : 45
FALSE                : 50 70 88
FN                   : 7 21 23
FOR                  : 34
GT                   : 67
GTE                  : 65
ID                   : 6 21 23 24 34 47 55 72 74 75 84 89
IF                   : 58 59
IN                   : 34
INT                  : 34 34 41 46 68 82 86
INTEGER              : 30
LCRLBRACKET          : 7 22 29 33 34 35 36 58 59 60 61 62
LET                  : 74 75
LOOP                 : 33
LPAREN               : 7 21 23 35 37 38 41 45 76
LSQRBRACKET          : 38
LT                   : 66
LTE                  : 64
MAIN                 : 7
MIL                  : 43
MIN                  : 42
MINUS                : 78 86
MOVE                 : 37 38
OPERA                : 76
PLUS                 : 77
PRINT                : 45
QUOT                 : 42 42 43 43 44 44 55 55
RANGE                : 
RCRLBRACKET          : 7 22 29 33 34 35 36 58 59 60 61 62
RETURN               : 32
RPAREN               : 7 21 23 35 37 38 41 45 76
RSQRBRACKET          : 38
SEG                  : 44
SEMICOLON            : 32 37 38 41 45 74 75
STRING               : 37 39 39 40 41 51
TIMES                : 81
TRUE                 : 36 49 69 87
WHILE                : 35 36
WRONG_ID             : 
error                : 

Nonterminals, with rules where they appear

arg                  : 24 27
args                 : 45 52
body                 : 46 47 48 49 50 51 53
bool                 : 37 38 75
break                : 19
compare              : 35 58 59 60 61
delay                : 17
else                 : 57
elseif               : 56
elseiforelse         : 59 61
empty                : 5 5 20 20 25 25 28 28 54 54 58 60
end                  : 29
expression           : 32 35 35 58 58 59 59 60 60 61 61
fingerList           : 38 40
for                  : 11
funbody              : 23
function             : 2 9
functions            : 
if                   : 13
let                  : 4 14
line                 : 7 8 9 10 11 12 13 14 15 16 17 18 19 22 29 33 34 35 36 58 59 60 61 62
loop                 : 8
main                 : 1
move                 : 15
moveList             : 16
negative             : 73 85
opera                : 48 71 83
operand              : 74 76 76
operator             : 76
output               : 29
params               : 21 23 26
println              : 18
procedure            : 3 10
prodbody             : 21
root                 : 1 2 3 4 0
text                 : 
unit                 : 
while                : 12

Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    root                           shift and go to state 1
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 1

    (0) S' -> root .



state 2

    (1) root -> main . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    main                           shift and go to state 2
    root                           shift and go to state 9
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) root -> function . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    function                       shift and go to state 3
    root                           shift and go to state 10
    main                           shift and go to state 2
    procedure                      shift and go to state 4
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 4

    (3) root -> procedure . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    procedure                      shift and go to state 4
    root                           shift and go to state 11
    main                           shift and go to state 2
    function                       shift and go to state 3
    let                            shift and go to state 5
    empty                          shift and go to state 6

state 5

    (4) root -> let . root
    (1) root -> . main root
    (2) root -> . function root
    (3) root -> . procedure root
    (4) root -> . let root
    (5) root -> . empty empty
    (7) main -> . FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (91) empty -> .

    FN              shift and go to state 7
    LET             shift and go to state 8
    $end            reduce using rule 91 (empty -> .)

    let                            shift and go to state 5
    root                           shift and go to state 12
    main                           shift and go to state 2
    function                       shift and go to state 3
    procedure                      shift and go to state 4
    empty                          shift and go to state 6

state 6

    (5) root -> empty . empty
    (91) empty -> .

    $end            reduce using rule 91 (empty -> .)

    empty                          shift and go to state 13

state 7

    (7) main -> FN . MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET
    (23) function -> FN . ID LPAREN params RPAREN funbody
    (21) procedure -> FN . ID LPAREN params RPAREN prodbody

    MAIN            shift and go to state 14
    ID              shift and go to state 15


state 8

    (74) let -> LET . ID ASSIGN operand SEMICOLON
    (75) let -> LET . ID ASSIGN bool SEMICOLON

    ID              shift and go to state 16


state 9

    (1) root -> main root .

    $end            reduce using rule 1 (root -> main root .)


state 10

    (2) root -> function root .

    $end            reduce using rule 2 (root -> function root .)


state 11

    (3) root -> procedure root .

    $end            reduce using rule 3 (root -> procedure root .)


state 12

    (4) root -> let root .

    $end            reduce using rule 4 (root -> let root .)


state 13

    (5) root -> empty empty .

    $end            reduce using rule 5 (root -> empty empty .)


state 14

    (7) main -> FN MAIN . LPAREN RPAREN LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 17


state 15

    (23) function -> FN ID . LPAREN params RPAREN funbody
    (21) procedure -> FN ID . LPAREN params RPAREN prodbody

    LPAREN          shift and go to state 18


state 16

    (74) let -> LET ID . ASSIGN operand SEMICOLON
    (75) let -> LET ID . ASSIGN bool SEMICOLON

    ASSIGN          shift and go to state 19


state 17

    (7) main -> FN MAIN LPAREN . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 20


state 18

    (23) function -> FN ID LPAREN . params RPAREN funbody
    (21) procedure -> FN ID LPAREN . params RPAREN prodbody
    (24) params -> . ID arg
    (25) params -> . empty empty
    (91) empty -> .

    ID              shift and go to state 21
    RPAREN          reduce using rule 91 (empty -> .)

    params                         shift and go to state 22
    empty                          shift and go to state 23

state 19

    (74) let -> LET ID ASSIGN . operand SEMICOLON
    (75) let -> LET ID ASSIGN . bool SEMICOLON
    (82) operand -> . INT
    (83) operand -> . opera
    (84) operand -> . ID
    (85) operand -> . negative
    (87) bool -> . TRUE
    (88) bool -> . FALSE
    (89) bool -> . ID
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 27
    ID              shift and go to state 24
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    operand                        shift and go to state 25
    bool                           shift and go to state 26
    opera                          shift and go to state 28
    negative                       shift and go to state 29

state 20

    (7) main -> FN MAIN LPAREN RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 34


state 21

    (24) params -> ID . arg
    (26) arg -> . COMMA params
    (27) arg -> . COMMA arg
    (28) arg -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 36
    RPAREN          reduce using rule 91 (empty -> .)

    arg                            shift and go to state 35
    empty                          shift and go to state 37

state 22

    (23) function -> FN ID LPAREN params . RPAREN funbody
    (21) procedure -> FN ID LPAREN params . RPAREN prodbody

    RPAREN          shift and go to state 38


state 23

    (25) params -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 39

state 24

    (84) operand -> ID .
    (89) bool -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 84 (operand -> ID .)
    SEMICOLON       reduce using rule 84 (operand -> ID .)

  ! SEMICOLON       [ reduce using rule 89 (bool -> ID .) ]


state 25

    (74) let -> LET ID ASSIGN operand . SEMICOLON

    SEMICOLON       shift and go to state 40


state 26

    (75) let -> LET ID ASSIGN bool . SEMICOLON

    SEMICOLON       shift and go to state 41


state 27

    (82) operand -> INT .

    SEMICOLON       reduce using rule 82 (operand -> INT .)
    COMMA           reduce using rule 82 (operand -> INT .)
    RPAREN          reduce using rule 82 (operand -> INT .)


state 28

    (83) operand -> opera .

    SEMICOLON       reduce using rule 83 (operand -> opera .)
    COMMA           reduce using rule 83 (operand -> opera .)
    RPAREN          reduce using rule 83 (operand -> opera .)


state 29

    (85) operand -> negative .

    SEMICOLON       reduce using rule 85 (operand -> negative .)
    COMMA           reduce using rule 85 (operand -> negative .)
    RPAREN          reduce using rule 85 (operand -> negative .)


state 30

    (87) bool -> TRUE .

    SEMICOLON       reduce using rule 87 (bool -> TRUE .)
    RPAREN          reduce using rule 87 (bool -> TRUE .)


state 31

    (88) bool -> FALSE .

    SEMICOLON       reduce using rule 88 (bool -> FALSE .)
    RPAREN          reduce using rule 88 (bool -> FALSE .)


state 32

    (76) opera -> OPERA . LPAREN operator COMMA operand COMMA operand RPAREN

    LPAREN          shift and go to state 42


state 33

    (86) negative -> MINUS . INT

    INT             shift and go to state 43


state 34

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 45
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 35

    (24) params -> ID arg .

    RPAREN          reduce using rule 24 (params -> ID arg .)


state 36

    (26) arg -> COMMA . params
    (27) arg -> COMMA . arg
    (24) params -> . ID arg
    (25) params -> . empty empty
    (26) arg -> . COMMA params
    (27) arg -> . COMMA arg
    (28) arg -> . empty empty
    (91) empty -> .

    ID              shift and go to state 21
    COMMA           shift and go to state 36
    RPAREN          reduce using rule 91 (empty -> .)

    params                         shift and go to state 67
    arg                            shift and go to state 68
    empty                          shift and go to state 69

state 37

    (28) arg -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 70

state 38

    (23) function -> FN ID LPAREN params RPAREN . funbody
    (21) procedure -> FN ID LPAREN params RPAREN . prodbody
    (29) funbody -> . ARROW output LCRLBRACKET line end RCRLBRACKET
    (22) prodbody -> . LCRLBRACKET line RCRLBRACKET

    ARROW           shift and go to state 73
    LCRLBRACKET     shift and go to state 74

    funbody                        shift and go to state 71
    prodbody                       shift and go to state 72

state 39

    (25) params -> empty empty .

    RPAREN          reduce using rule 25 (params -> empty empty .)


state 40

    (74) let -> LET ID ASSIGN operand SEMICOLON .

    FN              reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    LET             reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    $end            reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    LOOP            reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    FOR             reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    WHILE           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    IF              reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    MOVE            reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    DELAY           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    PRINT           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    BREAK           reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    RCRLBRACKET     reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)
    RETURN          reduce using rule 74 (let -> LET ID ASSIGN operand SEMICOLON .)


state 41

    (75) let -> LET ID ASSIGN bool SEMICOLON .

    FN              reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    LET             reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    $end            reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    LOOP            reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    FOR             reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    WHILE           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    IF              reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    MOVE            reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    DELAY           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    PRINT           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    BREAK           reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    RCRLBRACKET     reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)
    RETURN          reduce using rule 75 (let -> LET ID ASSIGN bool SEMICOLON .)


state 42

    (76) opera -> OPERA LPAREN . operator COMMA operand COMMA operand RPAREN
    (77) operator -> . PLUS
    (78) operator -> . MINUS
    (79) operator -> . DIVIDE
    (80) operator -> . ASTR
    (81) operator -> . TIMES

    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    DIVIDE          shift and go to state 78
    ASTR            shift and go to state 79
    TIMES           shift and go to state 80

    operator                       shift and go to state 75

state 43

    (86) negative -> MINUS INT .

    SEMICOLON       reduce using rule 86 (negative -> MINUS INT .)
    EQEQ            reduce using rule 86 (negative -> MINUS INT .)
    LTE             reduce using rule 86 (negative -> MINUS INT .)
    GTE             reduce using rule 86 (negative -> MINUS INT .)
    LT              reduce using rule 86 (negative -> MINUS INT .)
    GT              reduce using rule 86 (negative -> MINUS INT .)
    COMMA           reduce using rule 86 (negative -> MINUS INT .)
    LCRLBRACKET     reduce using rule 86 (negative -> MINUS INT .)
    RPAREN          reduce using rule 86 (negative -> MINUS INT .)


state 44

    (23) function -> FN . ID LPAREN params RPAREN funbody
    (21) procedure -> FN . ID LPAREN params RPAREN prodbody

    ID              shift and go to state 15


state 45

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 81


state 46

    (8) line -> loop . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    loop                           shift and go to state 46
    line                           shift and go to state 82
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 47

    (9) line -> function . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    function                       shift and go to state 47
    line                           shift and go to state 83
    loop                           shift and go to state 46
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 48

    (10) line -> procedure . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    procedure                      shift and go to state 48
    line                           shift and go to state 84
    loop                           shift and go to state 46
    function                       shift and go to state 47
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 49

    (11) line -> for . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    for                            shift and go to state 49
    line                           shift and go to state 85
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 50

    (12) line -> while . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    while                          shift and go to state 50
    line                           shift and go to state 86
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 51

    (13) line -> if . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    if                             shift and go to state 51
    line                           shift and go to state 87
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 52

    (14) line -> let . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    let                            shift and go to state 52
    line                           shift and go to state 88
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 53

    (15) line -> move . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    move                           shift and go to state 53
    line                           shift and go to state 89
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 54

    (16) line -> moveList . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    moveList                       shift and go to state 54
    line                           shift and go to state 90
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 55

    (17) line -> delay . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    delay                          shift and go to state 55
    line                           shift and go to state 91
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 56

    (18) line -> println . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    println                        shift and go to state 56
    line                           shift and go to state 92
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 57

    (19) line -> break . line
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    break                          shift and go to state 57
    line                           shift and go to state 93
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    empty                          shift and go to state 58

state 58

    (20) line -> empty . empty
    (91) empty -> .

    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 94

state 59

    (33) loop -> LOOP . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 95


state 60

    (34) for -> FOR . ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    ID              shift and go to state 96


state 61

    (35) while -> WHILE . LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> WHILE . TRUE LCRLBRACKET line RCRLBRACKET

    LPAREN          shift and go to state 97
    TRUE            shift and go to state 98


state 62

    (58) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 99
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 63

    (37) move -> MOVE . LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> MOVE . LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    LPAREN          shift and go to state 106


state 64

    (41) delay -> DELAY . LPAREN INT COMMA STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 107


state 65

    (45) println -> PRINT . EXPR LPAREN args RPAREN SEMICOLON

    EXPR            shift and go to state 108


state 66

    (90) break -> BREAK .

    LOOP            reduce using rule 90 (break -> BREAK .)
    FN              reduce using rule 90 (break -> BREAK .)
    FOR             reduce using rule 90 (break -> BREAK .)
    WHILE           reduce using rule 90 (break -> BREAK .)
    IF              reduce using rule 90 (break -> BREAK .)
    LET             reduce using rule 90 (break -> BREAK .)
    MOVE            reduce using rule 90 (break -> BREAK .)
    DELAY           reduce using rule 90 (break -> BREAK .)
    PRINT           reduce using rule 90 (break -> BREAK .)
    BREAK           reduce using rule 90 (break -> BREAK .)
    RCRLBRACKET     reduce using rule 90 (break -> BREAK .)
    RETURN          reduce using rule 90 (break -> BREAK .)


state 67

    (26) arg -> COMMA params .

    RPAREN          reduce using rule 26 (arg -> COMMA params .)


state 68

    (27) arg -> COMMA arg .

    RPAREN          reduce using rule 27 (arg -> COMMA arg .)


state 69

    (25) params -> empty . empty
    (28) arg -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 109

state 70

    (28) arg -> empty empty .

    RPAREN          reduce using rule 28 (arg -> empty empty .)


state 71

    (23) function -> FN ID LPAREN params RPAREN funbody .

    FN              reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    LET             reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    $end            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    LOOP            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    FOR             reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    WHILE           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    IF              reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    MOVE            reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    DELAY           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    PRINT           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    BREAK           reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    RCRLBRACKET     reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)
    RETURN          reduce using rule 23 (function -> FN ID LPAREN params RPAREN funbody .)


state 72

    (21) procedure -> FN ID LPAREN params RPAREN prodbody .

    FN              reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LET             reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    $end            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    LOOP            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    FOR             reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    WHILE           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    IF              reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    MOVE            reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    DELAY           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    PRINT           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    BREAK           reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RCRLBRACKET     reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)
    RETURN          reduce using rule 21 (procedure -> FN ID LPAREN params RPAREN prodbody .)


state 73

    (29) funbody -> ARROW . output LCRLBRACKET line end RCRLBRACKET
    (30) output -> . INTEGER
    (31) output -> . BOOLEAN

    INTEGER         shift and go to state 111
    BOOLEAN         shift and go to state 112

    output                         shift and go to state 110

state 74

    (22) prodbody -> LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 113
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 75

    (76) opera -> OPERA LPAREN operator . COMMA operand COMMA operand RPAREN

    COMMA           shift and go to state 114


state 76

    (77) operator -> PLUS .

    COMMA           reduce using rule 77 (operator -> PLUS .)


state 77

    (78) operator -> MINUS .

    COMMA           reduce using rule 78 (operator -> MINUS .)


state 78

    (79) operator -> DIVIDE .

    COMMA           reduce using rule 79 (operator -> DIVIDE .)


state 79

    (80) operator -> ASTR .

    COMMA           reduce using rule 80 (operator -> ASTR .)


state 80

    (81) operator -> TIMES .

    COMMA           reduce using rule 81 (operator -> TIMES .)


state 81

    (7) main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 7 (main -> FN MAIN LPAREN RPAREN LCRLBRACKET line RCRLBRACKET .)


state 82

    (8) line -> loop line .

    RCRLBRACKET     reduce using rule 8 (line -> loop line .)
    RETURN          reduce using rule 8 (line -> loop line .)


state 83

    (9) line -> function line .

    RCRLBRACKET     reduce using rule 9 (line -> function line .)
    RETURN          reduce using rule 9 (line -> function line .)


state 84

    (10) line -> procedure line .

    RCRLBRACKET     reduce using rule 10 (line -> procedure line .)
    RETURN          reduce using rule 10 (line -> procedure line .)


state 85

    (11) line -> for line .

    RCRLBRACKET     reduce using rule 11 (line -> for line .)
    RETURN          reduce using rule 11 (line -> for line .)


state 86

    (12) line -> while line .

    RCRLBRACKET     reduce using rule 12 (line -> while line .)
    RETURN          reduce using rule 12 (line -> while line .)


state 87

    (13) line -> if line .

    RCRLBRACKET     reduce using rule 13 (line -> if line .)
    RETURN          reduce using rule 13 (line -> if line .)


state 88

    (14) line -> let line .

    RCRLBRACKET     reduce using rule 14 (line -> let line .)
    RETURN          reduce using rule 14 (line -> let line .)


state 89

    (15) line -> move line .

    RCRLBRACKET     reduce using rule 15 (line -> move line .)
    RETURN          reduce using rule 15 (line -> move line .)


state 90

    (16) line -> moveList line .

    RCRLBRACKET     reduce using rule 16 (line -> moveList line .)
    RETURN          reduce using rule 16 (line -> moveList line .)


state 91

    (17) line -> delay line .

    RCRLBRACKET     reduce using rule 17 (line -> delay line .)
    RETURN          reduce using rule 17 (line -> delay line .)


state 92

    (18) line -> println line .

    RCRLBRACKET     reduce using rule 18 (line -> println line .)
    RETURN          reduce using rule 18 (line -> println line .)


state 93

    (19) line -> break line .

    RCRLBRACKET     reduce using rule 19 (line -> break line .)
    RETURN          reduce using rule 19 (line -> break line .)


state 94

    (20) line -> empty empty .

    RCRLBRACKET     reduce using rule 20 (line -> empty empty .)
    RETURN          reduce using rule 20 (line -> empty empty .)


state 95

    (33) loop -> LOOP LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 115
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 96

    (34) for -> FOR ID . IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    IN              shift and go to state 116


state 97

    (35) while -> WHILE LPAREN . expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 117
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 98

    (36) while -> WHILE TRUE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 118


state 99

    (58) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT

    EQEQ            shift and go to state 120
    LTE             shift and go to state 121
    GTE             shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124

    compare                        shift and go to state 119

state 100

    (68) expression -> INT .

    EQEQ            reduce using rule 68 (expression -> INT .)
    LTE             reduce using rule 68 (expression -> INT .)
    GTE             reduce using rule 68 (expression -> INT .)
    LT              reduce using rule 68 (expression -> INT .)
    GT              reduce using rule 68 (expression -> INT .)
    LCRLBRACKET     reduce using rule 68 (expression -> INT .)
    RPAREN          reduce using rule 68 (expression -> INT .)
    SEMICOLON       reduce using rule 68 (expression -> INT .)


state 101

    (69) expression -> TRUE .

    EQEQ            reduce using rule 69 (expression -> TRUE .)
    LTE             reduce using rule 69 (expression -> TRUE .)
    GTE             reduce using rule 69 (expression -> TRUE .)
    LT              reduce using rule 69 (expression -> TRUE .)
    GT              reduce using rule 69 (expression -> TRUE .)
    LCRLBRACKET     reduce using rule 69 (expression -> TRUE .)
    RPAREN          reduce using rule 69 (expression -> TRUE .)
    SEMICOLON       reduce using rule 69 (expression -> TRUE .)


state 102

    (70) expression -> FALSE .

    EQEQ            reduce using rule 70 (expression -> FALSE .)
    LTE             reduce using rule 70 (expression -> FALSE .)
    GTE             reduce using rule 70 (expression -> FALSE .)
    LT              reduce using rule 70 (expression -> FALSE .)
    GT              reduce using rule 70 (expression -> FALSE .)
    LCRLBRACKET     reduce using rule 70 (expression -> FALSE .)
    RPAREN          reduce using rule 70 (expression -> FALSE .)
    SEMICOLON       reduce using rule 70 (expression -> FALSE .)


state 103

    (71) expression -> opera .

    EQEQ            reduce using rule 71 (expression -> opera .)
    LTE             reduce using rule 71 (expression -> opera .)
    GTE             reduce using rule 71 (expression -> opera .)
    LT              reduce using rule 71 (expression -> opera .)
    GT              reduce using rule 71 (expression -> opera .)
    LCRLBRACKET     reduce using rule 71 (expression -> opera .)
    RPAREN          reduce using rule 71 (expression -> opera .)
    SEMICOLON       reduce using rule 71 (expression -> opera .)


state 104

    (72) expression -> ID .

    EQEQ            reduce using rule 72 (expression -> ID .)
    LTE             reduce using rule 72 (expression -> ID .)
    GTE             reduce using rule 72 (expression -> ID .)
    LT              reduce using rule 72 (expression -> ID .)
    GT              reduce using rule 72 (expression -> ID .)
    LCRLBRACKET     reduce using rule 72 (expression -> ID .)
    RPAREN          reduce using rule 72 (expression -> ID .)
    SEMICOLON       reduce using rule 72 (expression -> ID .)


state 105

    (73) expression -> negative .

    EQEQ            reduce using rule 73 (expression -> negative .)
    LTE             reduce using rule 73 (expression -> negative .)
    GTE             reduce using rule 73 (expression -> negative .)
    LT              reduce using rule 73 (expression -> negative .)
    GT              reduce using rule 73 (expression -> negative .)
    LCRLBRACKET     reduce using rule 73 (expression -> negative .)
    RPAREN          reduce using rule 73 (expression -> negative .)
    SEMICOLON       reduce using rule 73 (expression -> negative .)


state 106

    (37) move -> MOVE LPAREN . STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> MOVE LPAREN . LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON

    STRING          shift and go to state 125
    LSQRBRACKET     shift and go to state 126


state 107

    (41) delay -> DELAY LPAREN . INT COMMA STRING RPAREN SEMICOLON

    INT             shift and go to state 127


state 108

    (45) println -> PRINT EXPR . LPAREN args RPAREN SEMICOLON

    LPAREN          shift and go to state 128


state 109

    (25) params -> empty empty .
    (28) arg -> empty empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 25 (params -> empty empty .)
    RPAREN          reduce using rule 25 (params -> empty empty .)

  ! RPAREN          [ reduce using rule 28 (arg -> empty empty .) ]


state 110

    (29) funbody -> ARROW output . LCRLBRACKET line end RCRLBRACKET

    LCRLBRACKET     shift and go to state 129


state 111

    (30) output -> INTEGER .

    LCRLBRACKET     reduce using rule 30 (output -> INTEGER .)


state 112

    (31) output -> BOOLEAN .

    LCRLBRACKET     reduce using rule 31 (output -> BOOLEAN .)


state 113

    (22) prodbody -> LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 130


state 114

    (76) opera -> OPERA LPAREN operator COMMA . operand COMMA operand RPAREN
    (82) operand -> . INT
    (83) operand -> . opera
    (84) operand -> . ID
    (85) operand -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 27
    ID              shift and go to state 132
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    operand                        shift and go to state 131
    opera                          shift and go to state 28
    negative                       shift and go to state 29

state 115

    (33) loop -> LOOP LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 133


state 116

    (34) for -> FOR ID IN . INT DOTDOT INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 134


state 117

    (35) while -> WHILE LPAREN expression . compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT

    EQEQ            shift and go to state 120
    LTE             shift and go to state 121
    GTE             shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124

    compare                        shift and go to state 135

state 118

    (36) while -> WHILE TRUE LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 136
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 119

    (58) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 137
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 120

    (63) compare -> EQEQ .

    INT             reduce using rule 63 (compare -> EQEQ .)
    TRUE            reduce using rule 63 (compare -> EQEQ .)
    FALSE           reduce using rule 63 (compare -> EQEQ .)
    ID              reduce using rule 63 (compare -> EQEQ .)
    OPERA           reduce using rule 63 (compare -> EQEQ .)
    MINUS           reduce using rule 63 (compare -> EQEQ .)


state 121

    (64) compare -> LTE .

    INT             reduce using rule 64 (compare -> LTE .)
    TRUE            reduce using rule 64 (compare -> LTE .)
    FALSE           reduce using rule 64 (compare -> LTE .)
    ID              reduce using rule 64 (compare -> LTE .)
    OPERA           reduce using rule 64 (compare -> LTE .)
    MINUS           reduce using rule 64 (compare -> LTE .)


state 122

    (65) compare -> GTE .

    INT             reduce using rule 65 (compare -> GTE .)
    TRUE            reduce using rule 65 (compare -> GTE .)
    FALSE           reduce using rule 65 (compare -> GTE .)
    ID              reduce using rule 65 (compare -> GTE .)
    OPERA           reduce using rule 65 (compare -> GTE .)
    MINUS           reduce using rule 65 (compare -> GTE .)


state 123

    (66) compare -> LT .

    INT             reduce using rule 66 (compare -> LT .)
    TRUE            reduce using rule 66 (compare -> LT .)
    FALSE           reduce using rule 66 (compare -> LT .)
    ID              reduce using rule 66 (compare -> LT .)
    OPERA           reduce using rule 66 (compare -> LT .)
    MINUS           reduce using rule 66 (compare -> LT .)


state 124

    (67) compare -> GT .

    INT             reduce using rule 67 (compare -> GT .)
    TRUE            reduce using rule 67 (compare -> GT .)
    FALSE           reduce using rule 67 (compare -> GT .)
    ID              reduce using rule 67 (compare -> GT .)
    OPERA           reduce using rule 67 (compare -> GT .)
    MINUS           reduce using rule 67 (compare -> GT .)


state 125

    (37) move -> MOVE LPAREN STRING . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 138


state 126

    (38) moveList -> MOVE LPAREN LSQRBRACKET . fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (39) fingerList -> . STRING COMMA STRING
    (40) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 140

    fingerList                     shift and go to state 139

state 127

    (41) delay -> DELAY LPAREN INT . COMMA STRING RPAREN SEMICOLON

    COMMA           shift and go to state 141


state 128

    (45) println -> PRINT EXPR LPAREN . args RPAREN SEMICOLON
    (46) args -> . INT body
    (47) args -> . ID body
    (48) args -> . opera body
    (49) args -> . TRUE body
    (50) args -> . FALSE body
    (51) args -> . STRING body
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN

    INT             shift and go to state 143
    ID              shift and go to state 144
    TRUE            shift and go to state 146
    FALSE           shift and go to state 147
    STRING          shift and go to state 148
    OPERA           shift and go to state 32

    args                           shift and go to state 142
    opera                          shift and go to state 145

state 129

    (29) funbody -> ARROW output LCRLBRACKET . line end RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RETURN          reduce using rule 91 (empty -> .)

    line                           shift and go to state 149
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 130

    (22) prodbody -> LCRLBRACKET line RCRLBRACKET .

    FN              reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    $end            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    LOOP            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 22 (prodbody -> LCRLBRACKET line RCRLBRACKET .)


state 131

    (76) opera -> OPERA LPAREN operator COMMA operand . COMMA operand RPAREN

    COMMA           shift and go to state 150


state 132

    (84) operand -> ID .

    COMMA           reduce using rule 84 (operand -> ID .)
    RPAREN          reduce using rule 84 (operand -> ID .)


state 133

    (33) loop -> LOOP LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 33 (loop -> LOOP LCRLBRACKET line RCRLBRACKET .)


state 134

    (34) for -> FOR ID IN INT . DOTDOT INT LCRLBRACKET line RCRLBRACKET

    DOTDOT          shift and go to state 151


state 135

    (35) while -> WHILE LPAREN expression compare . expression RPAREN LCRLBRACKET line RCRLBRACKET
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 152
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 136

    (36) while -> WHILE TRUE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 153


state 137

    (58) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (59) if -> IF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 154


state 138

    (37) move -> MOVE LPAREN STRING COMMA . bool RPAREN SEMICOLON
    (87) bool -> . TRUE
    (88) bool -> . FALSE
    (89) bool -> . ID

    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 156

    bool                           shift and go to state 155

state 139

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList . RSQRBRACKET COMMA bool RPAREN SEMICOLON

    RSQRBRACKET     shift and go to state 157


state 140

    (39) fingerList -> STRING . COMMA STRING
    (40) fingerList -> STRING . COMMA fingerList

    COMMA           shift and go to state 158


state 141

    (41) delay -> DELAY LPAREN INT COMMA . STRING RPAREN SEMICOLON

    STRING          shift and go to state 159


state 142

    (45) println -> PRINT EXPR LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 160


state 143

    (46) args -> INT . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 161
    empty                          shift and go to state 163

state 144

    (47) args -> ID . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 164
    empty                          shift and go to state 163

state 145

    (48) args -> opera . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 165
    empty                          shift and go to state 163

state 146

    (49) args -> TRUE . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 166
    empty                          shift and go to state 163

state 147

    (50) args -> FALSE . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 167
    empty                          shift and go to state 163

state 148

    (51) args -> STRING . body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (91) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 91 (empty -> .)

    body                           shift and go to state 168
    empty                          shift and go to state 163

state 149

    (29) funbody -> ARROW output LCRLBRACKET line . end RCRLBRACKET
    (32) end -> . RETURN expression SEMICOLON

    RETURN          shift and go to state 170

    end                            shift and go to state 169

state 150

    (76) opera -> OPERA LPAREN operator COMMA operand COMMA . operand RPAREN
    (82) operand -> . INT
    (83) operand -> . opera
    (84) operand -> . ID
    (85) operand -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 27
    ID              shift and go to state 132
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    operand                        shift and go to state 171
    opera                          shift and go to state 28
    negative                       shift and go to state 29

state 151

    (34) for -> FOR ID IN INT DOTDOT . INT LCRLBRACKET line RCRLBRACKET

    INT             shift and go to state 172


state 152

    (35) while -> WHILE LPAREN expression compare expression . RPAREN LCRLBRACKET line RCRLBRACKET

    RPAREN          shift and go to state 173


state 153

    (36) while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 36 (while -> WHILE TRUE LCRLBRACKET line RCRLBRACKET .)


state 154

    (58) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (59) if -> IF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 174
    empty                          shift and go to state 58
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57

state 155

    (37) move -> MOVE LPAREN STRING COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 175


state 156

    (89) bool -> ID .

    RPAREN          reduce using rule 89 (bool -> ID .)


state 157

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET . COMMA bool RPAREN SEMICOLON

    COMMA           shift and go to state 176


state 158

    (39) fingerList -> STRING COMMA . STRING
    (40) fingerList -> STRING COMMA . fingerList
    (39) fingerList -> . STRING COMMA STRING
    (40) fingerList -> . STRING COMMA fingerList

    STRING          shift and go to state 177

    fingerList                     shift and go to state 178

state 159

    (41) delay -> DELAY LPAREN INT COMMA STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 179


state 160

    (45) println -> PRINT EXPR LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 180


state 161

    (46) args -> INT body .

    RPAREN          reduce using rule 46 (args -> INT body .)


state 162

    (52) body -> COMMA . args
    (53) body -> COMMA . body
    (46) args -> . INT body
    (47) args -> . ID body
    (48) args -> . opera body
    (49) args -> . TRUE body
    (50) args -> . FALSE body
    (51) args -> . STRING body
    (52) body -> . COMMA args
    (53) body -> . COMMA body
    (54) body -> . empty empty
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (91) empty -> .

    INT             shift and go to state 143
    ID              shift and go to state 144
    TRUE            shift and go to state 146
    FALSE           shift and go to state 147
    STRING          shift and go to state 148
    COMMA           shift and go to state 162
    OPERA           shift and go to state 32
    RPAREN          reduce using rule 91 (empty -> .)

    args                           shift and go to state 181
    body                           shift and go to state 182
    opera                          shift and go to state 145
    empty                          shift and go to state 163

state 163

    (54) body -> empty . empty
    (91) empty -> .

    RPAREN          reduce using rule 91 (empty -> .)

    empty                          shift and go to state 183

state 164

    (47) args -> ID body .

    RPAREN          reduce using rule 47 (args -> ID body .)


state 165

    (48) args -> opera body .

    RPAREN          reduce using rule 48 (args -> opera body .)


state 166

    (49) args -> TRUE body .

    RPAREN          reduce using rule 49 (args -> TRUE body .)


state 167

    (50) args -> FALSE body .

    RPAREN          reduce using rule 50 (args -> FALSE body .)


state 168

    (51) args -> STRING body .

    RPAREN          reduce using rule 51 (args -> STRING body .)


state 169

    (29) funbody -> ARROW output LCRLBRACKET line end . RCRLBRACKET

    RCRLBRACKET     shift and go to state 184


state 170

    (32) end -> RETURN . expression SEMICOLON
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 185
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 171

    (76) opera -> OPERA LPAREN operator COMMA operand COMMA operand . RPAREN

    RPAREN          shift and go to state 186


state 172

    (34) for -> FOR ID IN INT DOTDOT INT . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 187


state 173

    (35) while -> WHILE LPAREN expression compare expression RPAREN . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 188


state 174

    (58) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (59) if -> IF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 189


state 175

    (37) move -> MOVE LPAREN STRING COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 190


state 176

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA . bool RPAREN SEMICOLON
    (87) bool -> . TRUE
    (88) bool -> . FALSE
    (89) bool -> . ID

    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 156

    bool                           shift and go to state 191

state 177

    (39) fingerList -> STRING COMMA STRING .
    (39) fingerList -> STRING . COMMA STRING
    (40) fingerList -> STRING . COMMA fingerList

    RSQRBRACKET     reduce using rule 39 (fingerList -> STRING COMMA STRING .)
    COMMA           shift and go to state 158


state 178

    (40) fingerList -> STRING COMMA fingerList .

    RSQRBRACKET     reduce using rule 40 (fingerList -> STRING COMMA fingerList .)


state 179

    (41) delay -> DELAY LPAREN INT COMMA STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 192


state 180

    (45) println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .

    LOOP            reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FN              reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    LET             reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    MOVE            reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    DELAY           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    PRINT           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    BREAK           reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 45 (println -> PRINT EXPR LPAREN args RPAREN SEMICOLON .)


state 181

    (52) body -> COMMA args .

    RPAREN          reduce using rule 52 (body -> COMMA args .)


state 182

    (53) body -> COMMA body .

    RPAREN          reduce using rule 53 (body -> COMMA body .)


state 183

    (54) body -> empty empty .

    RPAREN          reduce using rule 54 (body -> empty empty .)


state 184

    (29) funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .

    FN              reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LET             reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    $end            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    LOOP            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    FOR             reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    WHILE           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    IF              reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    MOVE            reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    DELAY           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    PRINT           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    BREAK           reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)
    RETURN          reduce using rule 29 (funbody -> ARROW output LCRLBRACKET line end RCRLBRACKET .)


state 185

    (32) end -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 193


state 186

    (76) opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .

    SEMICOLON       reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    EQEQ            reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LTE             reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GTE             reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LT              reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    GT              reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    COMMA           reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    LCRLBRACKET     reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)
    RPAREN          reduce using rule 76 (opera -> OPERA LPAREN operator COMMA operand COMMA operand RPAREN .)


state 187

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 194
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 188

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 195
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 189

    (58) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (59) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (91) empty -> .
    (56) elseiforelse -> . elseif
    (57) elseiforelse -> . else
    (60) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (62) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 91 (empty -> .)
    FN              reduce using rule 91 (empty -> .)
    FOR             reduce using rule 91 (empty -> .)
    WHILE           reduce using rule 91 (empty -> .)
    IF              reduce using rule 91 (empty -> .)
    LET             reduce using rule 91 (empty -> .)
    MOVE            reduce using rule 91 (empty -> .)
    DELAY           reduce using rule 91 (empty -> .)
    PRINT           reduce using rule 91 (empty -> .)
    BREAK           reduce using rule 91 (empty -> .)
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)
    ELSEIF          shift and go to state 200
    ELSE            shift and go to state 201

    empty                          shift and go to state 196
    elseiforelse                   shift and go to state 197
    elseif                         shift and go to state 198
    else                           shift and go to state 199

state 190

    (37) move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 37 (move -> MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON .)


state 191

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool . RPAREN SEMICOLON

    RPAREN          shift and go to state 202


state 192

    (41) delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .

    LOOP            reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FN              reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    IF              reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    LET             reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    MOVE            reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    DELAY           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    BREAK           reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 41 (delay -> DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON .)


state 193

    (32) end -> RETURN expression SEMICOLON .

    RCRLBRACKET     reduce using rule 32 (end -> RETURN expression SEMICOLON .)


state 194

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 203


state 195

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 204


state 196

    (58) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 58 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 197

    (59) if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 59 (if -> IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)


state 198

    (56) elseiforelse -> elseif .

    LOOP            reduce using rule 56 (elseiforelse -> elseif .)
    FN              reduce using rule 56 (elseiforelse -> elseif .)
    FOR             reduce using rule 56 (elseiforelse -> elseif .)
    WHILE           reduce using rule 56 (elseiforelse -> elseif .)
    IF              reduce using rule 56 (elseiforelse -> elseif .)
    LET             reduce using rule 56 (elseiforelse -> elseif .)
    MOVE            reduce using rule 56 (elseiforelse -> elseif .)
    DELAY           reduce using rule 56 (elseiforelse -> elseif .)
    PRINT           reduce using rule 56 (elseiforelse -> elseif .)
    BREAK           reduce using rule 56 (elseiforelse -> elseif .)
    RCRLBRACKET     reduce using rule 56 (elseiforelse -> elseif .)
    RETURN          reduce using rule 56 (elseiforelse -> elseif .)


state 199

    (57) elseiforelse -> else .

    LOOP            reduce using rule 57 (elseiforelse -> else .)
    FN              reduce using rule 57 (elseiforelse -> else .)
    FOR             reduce using rule 57 (elseiforelse -> else .)
    WHILE           reduce using rule 57 (elseiforelse -> else .)
    IF              reduce using rule 57 (elseiforelse -> else .)
    LET             reduce using rule 57 (elseiforelse -> else .)
    MOVE            reduce using rule 57 (elseiforelse -> else .)
    DELAY           reduce using rule 57 (elseiforelse -> else .)
    PRINT           reduce using rule 57 (elseiforelse -> else .)
    BREAK           reduce using rule 57 (elseiforelse -> else .)
    RCRLBRACKET     reduce using rule 57 (elseiforelse -> else .)
    RETURN          reduce using rule 57 (elseiforelse -> else .)


state 200

    (60) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF . expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 205
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 201

    (62) else -> ELSE . LCRLBRACKET line RCRLBRACKET

    LCRLBRACKET     shift and go to state 206


state 202

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 207


state 203

    (34) for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 34 (for -> FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET .)


state 204

    (35) while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 35 (while -> WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET .)


state 205

    (60) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression . compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (63) compare -> . EQEQ
    (64) compare -> . LTE
    (65) compare -> . GTE
    (66) compare -> . LT
    (67) compare -> . GT

    EQEQ            shift and go to state 120
    LTE             shift and go to state 121
    GTE             shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124

    compare                        shift and go to state 208

state 206

    (62) else -> ELSE LCRLBRACKET . line RCRLBRACKET
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 209
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57
    empty                          shift and go to state 58

state 207

    (38) moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .

    LOOP            reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FN              reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    FOR             reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    WHILE           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    IF              reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    LET             reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    MOVE            reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    DELAY           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    PRINT           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    BREAK           reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RCRLBRACKET     reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)
    RETURN          reduce using rule 38 (moveList -> MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON .)


state 208

    (60) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare . expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (68) expression -> . INT
    (69) expression -> . TRUE
    (70) expression -> . FALSE
    (71) expression -> . opera
    (72) expression -> . ID
    (73) expression -> . negative
    (76) opera -> . OPERA LPAREN operator COMMA operand COMMA operand RPAREN
    (86) negative -> . MINUS INT

    INT             shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 104
    OPERA           shift and go to state 32
    MINUS           shift and go to state 33

    expression                     shift and go to state 210
    opera                          shift and go to state 103
    negative                       shift and go to state 105

state 209

    (62) else -> ELSE LCRLBRACKET line . RCRLBRACKET

    RCRLBRACKET     shift and go to state 211


state 210

    (60) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression . LCRLBRACKET line RCRLBRACKET elseiforelse

    LCRLBRACKET     shift and go to state 212


state 211

    (62) else -> ELSE LCRLBRACKET line RCRLBRACKET .

    LOOP            reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FN              reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    FOR             reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    WHILE           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    IF              reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    LET             reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    MOVE            reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    DELAY           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    PRINT           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    BREAK           reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RCRLBRACKET     reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)
    RETURN          reduce using rule 62 (else -> ELSE LCRLBRACKET line RCRLBRACKET .)


state 212

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET . line RCRLBRACKET elseiforelse
    (8) line -> . loop line
    (9) line -> . function line
    (10) line -> . procedure line
    (11) line -> . for line
    (12) line -> . while line
    (13) line -> . if line
    (14) line -> . let line
    (15) line -> . move line
    (16) line -> . moveList line
    (17) line -> . delay line
    (18) line -> . println line
    (19) line -> . break line
    (20) line -> . empty empty
    (33) loop -> . LOOP LCRLBRACKET line RCRLBRACKET
    (23) function -> . FN ID LPAREN params RPAREN funbody
    (21) procedure -> . FN ID LPAREN params RPAREN prodbody
    (34) for -> . FOR ID IN INT DOTDOT INT LCRLBRACKET line RCRLBRACKET
    (35) while -> . WHILE LPAREN expression compare expression RPAREN LCRLBRACKET line RCRLBRACKET
    (36) while -> . WHILE TRUE LCRLBRACKET line RCRLBRACKET
    (58) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (59) if -> . IF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (74) let -> . LET ID ASSIGN operand SEMICOLON
    (75) let -> . LET ID ASSIGN bool SEMICOLON
    (37) move -> . MOVE LPAREN STRING COMMA bool RPAREN SEMICOLON
    (38) moveList -> . MOVE LPAREN LSQRBRACKET fingerList RSQRBRACKET COMMA bool RPAREN SEMICOLON
    (41) delay -> . DELAY LPAREN INT COMMA STRING RPAREN SEMICOLON
    (45) println -> . PRINT EXPR LPAREN args RPAREN SEMICOLON
    (90) break -> . BREAK
    (91) empty -> .

    LOOP            shift and go to state 59
    FN              shift and go to state 44
    FOR             shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62
    LET             shift and go to state 8
    MOVE            shift and go to state 63
    DELAY           shift and go to state 64
    PRINT           shift and go to state 65
    BREAK           shift and go to state 66
    RCRLBRACKET     reduce using rule 91 (empty -> .)

    line                           shift and go to state 213
    empty                          shift and go to state 58
    loop                           shift and go to state 46
    function                       shift and go to state 47
    procedure                      shift and go to state 48
    for                            shift and go to state 49
    while                          shift and go to state 50
    if                             shift and go to state 51
    let                            shift and go to state 52
    move                           shift and go to state 53
    moveList                       shift and go to state 54
    delay                          shift and go to state 55
    println                        shift and go to state 56
    break                          shift and go to state 57

state 213

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line . RCRLBRACKET elseiforelse

    RCRLBRACKET     shift and go to state 214


state 214

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . empty
    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET . elseiforelse
    (91) empty -> .
    (56) elseiforelse -> . elseif
    (57) elseiforelse -> . else
    (60) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty
    (61) elseif -> . ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse
    (62) else -> . ELSE LCRLBRACKET line RCRLBRACKET

    LOOP            reduce using rule 91 (empty -> .)
    FN              reduce using rule 91 (empty -> .)
    FOR             reduce using rule 91 (empty -> .)
    WHILE           reduce using rule 91 (empty -> .)
    IF              reduce using rule 91 (empty -> .)
    LET             reduce using rule 91 (empty -> .)
    MOVE            reduce using rule 91 (empty -> .)
    DELAY           reduce using rule 91 (empty -> .)
    PRINT           reduce using rule 91 (empty -> .)
    BREAK           reduce using rule 91 (empty -> .)
    RCRLBRACKET     reduce using rule 91 (empty -> .)
    RETURN          reduce using rule 91 (empty -> .)
    ELSEIF          shift and go to state 200
    ELSE            shift and go to state 201

    empty                          shift and go to state 215
    elseiforelse                   shift and go to state 216
    elseif                         shift and go to state 198
    else                           shift and go to state 199

state 215

    (60) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .

    LOOP            reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FN              reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    FOR             reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    WHILE           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    IF              reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    LET             reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    MOVE            reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    DELAY           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    PRINT           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    BREAK           reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RCRLBRACKET     reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)
    RETURN          reduce using rule 60 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET empty .)


state 216

    (61) elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .

    LOOP            reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FN              reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    FOR             reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    WHILE           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    IF              reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    LET             reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    MOVE            reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    DELAY           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    PRINT           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    BREAK           reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RCRLBRACKET     reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)
    RETURN          reduce using rule 61 (elseif -> ELSEIF expression compare expression LCRLBRACKET line RCRLBRACKET elseiforelse .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 24 resolved using rule (operand -> ID)
WARNING: rejected rule (bool -> ID) in state 24
WARNING: reduce/reduce conflict in state 109 resolved using rule (params -> empty empty)
WARNING: rejected rule (arg -> empty empty) in state 109
